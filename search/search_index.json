{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#deczoo","title":"Deczoo","text":"<p>A zoo for decorators</p> <p>There are many great decorators out there that we use everyday. Why don't collect a few of them?</p> <p>I found myself implementing over and over some common decorators in different projects. The hope is to gather them here and use this codebase.</p> <p>Documentation: https://fbruzzesi.github.io/deczoo</p> <p>Source Code: https://github.com/fbruzzesi/deczoo</p>"},{"location":"#alpha-notice","title":"Alpha Notice","text":"<p>This codebase is experimental and is working for my use cases. It is very probable that there are cases not covered and for which it breaks (badly). If you find them, please feel free to open an issue in the issue page of the repo.</p>"},{"location":"#what-is-a-decorator","title":"What is a decorator?","text":"<p>In short a python decorator is a way to modify or enhance the behavior of a function or a class without actually modifying the source code of the function or class.</p> <p>Decorators are implemented as functions (or classes) that take a function or a class as input and return a new function or class that has some additional functionality.</p> <p>To have a more in-depth explanation you can check the next section.</p>"},{"location":"#installation","title":"Installation","text":"<p>deczoo is published as a Python package on pypi, and it can be installed with pip, directly from source using git, or with a local clone:</p> pip (pypi)source/gitlocal clone <pre><code>python -m pip install deczoo\n</code></pre> <pre><code>python -m pip install git+https://github.com/FBruzzesi/deczoo.git\n</code></pre> <pre><code>git clone https://github.com/FBruzzesi/deczoo.git\ncd deczoo\npython -m pip install .\n</code></pre>"},{"location":"#dependencies","title":"Dependencies","text":"<p>As of now, the library has no additional required dependencies, however:</p> <ul> <li>some functionalities works only on UNIX systems (<code>@memory_limit</code> and <code>@timeout</code>)</li> <li>to use some decorators you may need to install additional dependencies (e.g. install <code>chime</code> to use <code>@chime_on_end</code>)</li> </ul>"},{"location":"#license","title":"License","text":"<p>The project has a MIT Licence</p>"},{"location":"contribute/","title":"Contributing","text":""},{"location":"contribute/#guidelines","title":"Guidelines","text":"<p>We welcome contributions to the library! If you have a bug fix or new feature that you would like to contribute, please follow the steps below:</p> <ol> <li>Fork the repository on GitHub.</li> <li>Clone the repository to your local machine.</li> <li>Create a new branch for your bug fix or feature.</li> <li>Make your changes and test them thoroughly, making sure that it passes all current tests.</li> <li>Commit your changes and push the branch to your fork.</li> <li>Open a pull request on the main repository.</li> </ol>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the project's code of conduct, which is based on the Contributor Covenant.</p>"},{"location":"contribute/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in the library, please report it by opening an issue on GitHub. Be sure to include the version of the library you're using, as well as any error messages or tracebacks and a reproducible example.</p>"},{"location":"contribute/#requesting-features","title":"Requesting Features","text":"<p>If you have a suggestion for a new feature, please open an issue on GitHub. Be sure to explain the problem that you're trying to solve and how you think the feature would solve it.</p>"},{"location":"contribute/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>When submitting a pull request, please make sure that you've followed the steps above and that your code has been thoroughly tested. Also, be sure to include a brief summary of the changes you've made and a reference to any issues that your pull request resolves.</p>"},{"location":"contribute/#code-formatting","title":"Code formatting","text":"<p>Compclasses uses black and isort with the following  parameters for code formatting:</p> <pre><code>isort --profile black -l 90 deczoo tests\nblack --target-version py38 --line-length 90 deczoo tests\n</code></pre> <p>As part of the checks on pull requests, it is checked whether the code follows those standards. To ensure that the standard is met, it is recommanded to install pre-commit hooks:</p> <pre><code>python -m pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contribute/#developing","title":"Developing","text":"<p>Let's suppose that you already did steps 1-3 from the above list, now you should install the library and its developing dependencies  in editable way.</p> <p>First move into the repo folder: <code>cd deczoo</code>.</p> <p>Then:</p> with makewithout make <pre><code>make init-dev\n</code></pre> <pre><code>pip install -e \".[all]\" --no-cache-dir\npre-commit install\n</code></pre> <p>Now you are ready to proceed with all the changes you want to!</p>"},{"location":"contribute/#testing","title":"Testing","text":"<p>Once you are done with changes, you should:</p> <ul> <li>add tests for the new features in the <code>/tests</code> folder</li> <li> <p>make sure that new features do not break existing codebase by running tests:</p> with makewithout make <pre><code>make test\n</code></pre> <pre><code>pytest tests -vv\n</code></pre> </li> </ul>"},{"location":"contribute/#docs","title":"Docs","text":"<p>The documentation is generated using mkdocs-material, the API part uses mkdocstrings.</p> <p>If a breaking feature is developed, then we suggest to update documentation in the <code>/docs</code> folder as well, in order to describe how this can be used from a user perspective.</p>"},{"location":"quickstart/","title":"Getting started","text":"<p>The idea is kind of simple: each function in the library is a (function) decorator with a specific objective in mind.</p> Example: log decorator<pre><code>from deczoo import log\n@log # equivalent to @log(log_time=True, log_args=True, log_error=True, logging_fn=print)\ndef custom_add(a, b, *args):\n\"\"\"Adds all arguments together\"\"\"\nreturn sum([a, b, *args])\n_ = custom_add(1, 2, 3, 4)\n# custom_add args=(a=1, b=2, args=(3, 4)) time=0:00:00.000062\n_ = custom_add(1, \"a\", 2)\n# custom_add args=(a=1, b=a, args=(2,)) time=0:00:00.000064 Failed with error: unsupported\n# operand type(s) for +: 'int' and 'str'\n</code></pre> Example: shape_tracker decorator<pre><code>from deczoo import shape_tracker\n@shape_tracker(shape_in=True, shape_out=True, shape_delta=True, raise_if_empty=True)\ndef tracked_vstack(a: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\nreturn np.vstack([a, b])\n_ = tracked_vstack(np.ones((1, 2)), np.ones((10, 2)))\n# Input: `a` has shape (1, 2)\n# Output: result has shape (11, 2)\n# Shape delta: (-10, 0)\n</code></pre>"},{"location":"quickstart/#features","title":"Features","text":"<p>The library implements the following decorators:</p> <ul> <li><code>call_counter</code>: tracks how many times a function has been called.</li> <li><code>catch</code>: wraps a function in a try-except block, returning a custom value, or raising a custom exception.</li> <li><code>check_args</code>: checks that function arguments satisfy its \"rule\".</li> <li><code>chime_on_end</code>: notify with chime sound on function end (success or error).</li> <li><code>log</code>: tracks function time taken, arguments and errors, such logs can be written to a file.</li> <li><code>timer</code>: tracks function time taken.</li> <li><code>memory_limit</code>: sets a memory limit while running the function.</li> <li><code>notify_on_end</code>: notifies when function finished running with a custom notifier.</li> <li><code>retry</code>: wraps a function with a \"retry\" block.</li> <li><code>shape_tracker</code>: tracks the shape of a dataframe/array-like object, in input and/or output.</li> <li><code>multi_shape_tracker</code>: tracks the shapes of input(s) and/or output(s) of a function.</li> <li><code>timeout</code>: sets a time limit for the function, terminates the process if it hasn't finished within such time limit.</li> </ul>"},{"location":"quickstart/#examples","title":"Examples","text":"<p>Please refer to the api page to see a basic example for each decorator.</p>"},{"location":"api/decorators/","title":"Available Decorators","text":""},{"location":"api/decorators/#deczoo.decorators.call_counter","title":"<code>call_counter(func=None, seed=0, log_counter=True, logging_fn=LOGGING_FN)</code>","text":"<p>Counts how many times a function has been called by setting and tracking a <code>_calls</code> attribute to the decorated function.</p> <p><code>_calls</code> is set from a given <code>seed</code> value, and incremented by 1 each time the function is called.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>seed</code> <code>int</code> <p>Counter start</p> <code>0</code> <code>log_counter</code> <code>bool</code> <p>Whether or not to log <code>_calls</code> value each time the function is called</p> <code>True</code> <code>logging_fn</code> <code>Callable</code> <p>Log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>seed</code> is not an int, <code>log_counter</code> is not a bool, or <code>logging_fn</code> is not a callable wjhen <code>log_counter</code> is True.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Usage: <pre><code>from deczoo import call_counter\n@call_counter(seed=0, log_counter=False)\ndef add(a, b):\nreturn a+b\nfor _ in range(3):\nadd(1,2)\nadd._calls\n3\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef call_counter(\nfunc: Optional[Callable] = None,\nseed: int = 0,\nlog_counter: bool = True,\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Counts how many times a function has been called by setting and tracking a `_calls`\n    attribute to the decorated function.\n    `_calls` is set from a given `seed` value, and incremented by 1 each time the\n    function is called.\n    Arguments:\n        func: Function to decorate\n        seed: Counter start\n        log_counter: Whether or not to log `_calls` value each time the function is called\n        logging_fn: Log function (e.g. print, logger.info, rich console.print)\n    Raises:\n        TypeError: If `seed` is not an int, `log_counter` is not a bool, or `logging_fn`\n            is not a callable wjhen `log_counter` is True.\n    Returns:\n        Decorated function\n    Usage:\n    ```python\n    from deczoo import call_counter\n    @call_counter(seed=0, log_counter=False)\n    def add(a, b):\n        return a+b\n    for _ in range(3):\n        add(1,2)\n    add._calls\n    3\n    ```\n    \"\"\"\nif not isinstance(seed, int):\nraise TypeError(\"`seed` argument must be an int\")\nif not isinstance(log_counter, bool):\nraise TypeError(\"`log_counter` argument must be a bool\")\nif (log_counter is True) and (not callable(logging_fn)):\nraise TypeError(\"`logging_fn` argument must be a callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\nwrapper._calls += 1\nif log_counter:\nlogging_fn(f\"{func.__name__} called {wrapper._calls} times\")\nreturn func(*args, **kwargs)\n# set counter dynamically\nwrapper._calls = seed  # type: ignore\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.catch","title":"<code>catch(func=None, return_on_exception=None, raise_on_exception=None, logging_fn=LOGGING_FN)</code>","text":"<p>Wraps a function in a try-except block, potentially prevent exception to be raised by returning a given value or raises custom exception.</p> <p>Remark that if both <code>return_on_exception</code> and <code>raise_on_exception</code> are provided, <code>return_on_exception</code> will be used.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>return_on_exception</code> <code>Optional[Any]</code> <p>Value to return on exception</p> <code>None</code> <code>raise_on_exception</code> <code>Optional[Any]</code> <p>Error to raise on exception</p> <code>None</code> <code>logging_fn</code> <code>Callable</code> <p>Log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>logging_fn</code> is not a callable</p> <p>Usage: <pre><code>from deczoo import catch\n@catch(return_on_exception=-999)\ndef add(a, b):\nreturn a+b\nadd(1, 2)\n3\nadd(1, \"a\")\n-999\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef catch(\nfunc: Optional[Callable] = None,\nreturn_on_exception: Optional[Any] = None,\nraise_on_exception: Optional[Any] = None,\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Wraps a function in a try-except block, potentially prevent exception to be raised by\n    returning a given value or raises custom exception.\n    Remark that if both `return_on_exception` and `raise_on_exception` are provided,\n    `return_on_exception` will be used.\n    Arguments:\n        func: Function to decorate\n        return_on_exception: Value to return on exception\n        raise_on_exception: Error to raise on exception\n        logging_fn: Log function (e.g. print, logger.info, rich console.print)\n    Returns:\n        Decorated function\n    Raises:\n        TypeError: If `logging_fn` is not a callable\n    Usage:\n    ```python\n    from deczoo import catch\n    @catch(return_on_exception=-999)\n    def add(a, b):\n        return a+b\n    add(1, 2)\n    3\n    add(1, \"a\")\n    -999\n    ```\n    \"\"\"\nif not callable(logging_fn):\nraise TypeError(\"`logging_fn` argument must be a callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\ntry:\nreturn func(*args, **kwargs)\nexcept Exception as e:\nif return_on_exception is not None:\nlogging_fn(f\"Failed with error {e}, returning {return_on_exception}\")\nreturn return_on_exception\nelif raise_on_exception is not None:\nlogging_fn(f\"Failed with error {e}\")\nraise raise_on_exception\nelse:\nlogging_fn(f\"Failed with error {e}\")\nraise e\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.check_args","title":"<code>check_args(func=None, **rules)</code>","text":"<p>Checks that function arguments satisfy given rules, if not a <code>ValueError</code> is raised.</p> <p>Each <code>rule</code> should be a keyword argument with the name of the argument to check, and the value should be a function/callable that takes the argument value and returns a boolean.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>rules</code> <code>Callable[[Any], bool]</code> <p>Rules to be satisfied, each rule is a callable that takes the argument value and returns a boolean</p> <code>{}</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If any rule is not a callable</p> <code>ValueError</code> <p>If any decorated function argument doesn't satisfy its rule</p> <p>Usage: <pre><code>from deczoo import check_args\n@check_args(a=lambda t: t&gt;0)\ndef add(a, b): return a+b\nadd(1,2)\n3\nadd(-2, 2)\n# ValueError: Argument `a` doesn't satisfy its rule\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef check_args(\nfunc: Optional[Callable] = None, **rules: Callable[[Any], bool]\n) -&gt; Callable:\n\"\"\"\n    Checks that function arguments satisfy given rules, if not a `ValueError` is raised.\n    Each `rule` should be a keyword argument with the name of the argument to check,\n    and the value should be a function/callable that takes the argument value and\n    returns a boolean.\n    Arguments:\n        func: Function to decorate\n        rules: Rules to be satisfied, each rule is a callable that takes the argument\n            value and returns a boolean\n    Returns:\n        Decorated function\n    Raises:\n        ValueError: If any rule is not a callable\n        ValueError: If any decorated function argument doesn't satisfy its rule\n    Usage:\n    ```python\n    from deczoo import check_args\n    @check_args(a=lambda t: t&gt;0)\n    def add(a, b): return a+b\n    add(1,2)\n    3\n    add(-2, 2)\n    # ValueError: Argument `a` doesn't satisfy its rule\n    ```\n    \"\"\"\nif not all(callable(rule) for rule in rules.values()):\nraise ValueError(\"All rules must be callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs) -&gt; Callable:\nfunc_args = (\ninspect.signature(func).bind(*args, **kwargs).arguments  # type: ignore\n)\nfor k, v in func_args.items():\nrule = rules.get(k)\nif rule is not None:\nif not rule(v):\nraise ValueError(f\"Argument `{k}` doesn't satisfy its rule\")\nres = func(*args, **kwargs)  # type: ignore\nreturn res\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.chime_on_end","title":"<code>chime_on_end(func=None, theme='mario')</code>","text":"<p>Notify with chime sound when function ends successfully or fails.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>theme</code> <code>Optional[str]</code> <p>Chime theme to use</p> <code>'mario'</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Usage: <pre><code>from deczoo import chime_on_end\n@chime_on_end\ndef add(a, b): return a+b\n_ = add(1, 2)\n# you should hear a sound now!\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef chime_on_end(\nfunc: Optional[Callable] = None, theme: Optional[str] = \"mario\"\n) -&gt; Callable:\n\"\"\"\n    Notify with [chime](https://github.com/MaxHalford/chime) sound when function\n    ends successfully or fails.\n    Arguments:\n        func: Function to decorate\n        theme: Chime theme to use\n    Returns:\n        Decorated function\n    Usage:\n    ```python\n    from deczoo import chime_on_end\n    @chime_on_end\n    def add(a, b): return a+b\n    _ = add(1, 2)\n    # you should hear a sound now!\n    ```\n    \"\"\"\nimport chime\nchime.theme(theme)\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\ntry:\nres = func(*args, **kwargs)\nchime.success()\nreturn res\nexcept Exception as e:\nchime.error()\nraise e\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.log","title":"<code>log(func=None, log_time=True, log_args=True, log_error=True, log_file=None, logging_fn=LOGGING_FN)</code>","text":"<p>Tracks function time taken, arguments and errors. If <code>log_file</code> is provided, logs are written to file. In any case, logs are passed to <code>logging_fn</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>log_time</code> <code>bool</code> <p>Whether or not to track time taken</p> <code>True</code> <code>log_args</code> <code>bool</code> <p>Whether or not to track arguments</p> <code>True</code> <code>log_error</code> <code>bool</code> <p>Whether or not to track error</p> <code>True</code> <code>log_file</code> <code>Optional[Union[Path, str]]</code> <p>Filepath where to write/save log string</p> <code>None</code> <code>logging_fn</code> <code>Callable</code> <p>Log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function with logging capabilities</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if <code>log_time</code>, <code>log_args</code> or <code>log_error</code> are not <code>bool</code> or <code>log_file</code>             is not <code>None</code>, <code>str</code> or <code>Path</code></p> <p>Usage: <pre><code>from deczoo import log\n@log\ndef add(a, b): return a+b\n_ = add(1, 2)\n# add args=(a=1, b=2) time=0:00:00.000111\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef log(\nfunc: Optional[Callable] = None,\nlog_time: bool = True,\nlog_args: bool = True,\nlog_error: bool = True,\nlog_file: Optional[Union[Path, str]] = None,\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Tracks function time taken, arguments and errors. If `log_file` is provided, logs\n    are written to file. In any case, logs are passed to `logging_fn`.\n    Arguments:\n        func: Function to decorate\n        log_time: Whether or not to track time taken\n        log_args: Whether or not to track arguments\n        log_error: Whether or not to track error\n        log_file: Filepath where to write/save log string\n        logging_fn: Log function (e.g. print, logger.info, rich console.print)\n    Returns:\n        Decorated function with logging capabilities\n    Raises:\n        TypeError: if `log_time`, `log_args` or `log_error` are not `bool` or `log_file` \\\n            is not `None`, `str` or `Path`\n    Usage:\n    ```python\n    from deczoo import log\n    @log\n    def add(a, b): return a+b\n    _ = add(1, 2)\n    # add args=(a=1, b=2) time=0:00:00.000111\n    ```\n    \"\"\"\nif not all(isinstance(x, bool) for x in [log_time, log_args, log_error]):\nraise TypeError(\"`log_time`, `log_args` and `log_error` must be bool\")\nif log_file is not None and not isinstance(log_file, (str, Path)):\nraise TypeError(\"`log_file` must be either None, str or Path\")\nif not callable(logging_fn):\nraise TypeError(\"`logging_fn` must be callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\ntic = time.perf_counter()\nif log_args:\nfunc_args = inspect.signature(func).bind(*args, **kwargs).arguments\nfunc_args_str = \", \".join(f\"{k}={v}\" for k, v in func_args.items())\noptional_strings = [f\"args=({func_args_str})\"]\nelse:\noptional_strings = []\ntry:\nres = func(*args, **kwargs)\ntoc = time.perf_counter()\noptional_strings += [\nf\"time={toc - tic}\" if log_time else None,\n]\nreturn res\nexcept Exception as e:\ntoc = time.perf_counter()\noptional_strings += [\nf\"time={toc - tic}\" if log_time else None,\n\"Failed\" + (f\" with error: {e}\" if log_error else \"\"),\n]\nraise e\nfinally:\nlog_string = f\"{func.__name__} {' '.join([s for s in optional_strings if s])}\"\nlogging_fn(log_string)\nif log_file is not None:\nwith open(log_file, \"a\") as f:\nf.write(f\"{tic} {log_string}\\n\")\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.memory_limit","title":"<code>memory_limit(func=None, percentage=0.99, logging_fn=LOGGING_FN)</code>","text":"<p>Sets a memory limit while running the decorated function.</p> <p>Warning: This decorator is supported on unix-based systems only!</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>percentage</code> <code>float</code> <p>Percentage of the currently available memory to use</p> <code>0.99</code> <code>logging_fn</code> <code>Callable</code> <p>Log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Raises:</p> Type Description <code>TypeError</code> <p>If <code>percentage</code> is not a <code>float</code></p> <code>ValueError</code> <p>If <code>percentage</code> is not between 0 and 1</p> <code>MemoryError</code> <p>If memory limit is reached when decorated function is called</p> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Usage: <pre><code>from deczoo import memory_limit\n# Running on WSL2 with 12 Gb RAM\n@memory_limit(percentage=0.05)\ndef limited():\nfor i in list(range(10 ** 8)):\n_ = 1 + 1\nreturn \"done\"\ndef unlimited():\nfor i in list(range(10 ** 8)):\n_ = 1 + 1\nreturn \"done\"\nlimited()\n# MemoryError: Reached memory limit\nunlimited()\ndone\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef memory_limit(\nfunc: Optional[Callable] = None,\npercentage: float = 0.99,\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Sets a memory limit while running the decorated function.\n    **Warning**: This decorator is supported on unix-based systems only!\n    Arguments:\n        func: Function to decorate\n        percentage: Percentage of the currently available memory to use\n        logging_fn: Log function (e.g. print, logger.info, rich console.print)\n    Raises:\n        TypeError: If `percentage` is not a `float`\n        ValueError: If `percentage` is not between 0 and 1\n        MemoryError: If memory limit is reached when decorated function is called\n    Returns:\n        Decorated function\n    Usage:\n    ```python\n    from deczoo import memory_limit\n    # Running on WSL2 with 12 Gb RAM\n    @memory_limit(percentage=0.05)\n    def limited():\n        for i in list(range(10 ** 8)):\n            _ = 1 + 1\n        return \"done\"\n    def unlimited():\n        for i in list(range(10 ** 8)):\n            _ = 1 + 1\n        return \"done\"\n    limited()\n    # MemoryError: Reached memory limit\n    unlimited()\n    done\n    ```\n    \"\"\"\nif not isinstance(percentage, float):\nraise TypeError(\"`percentage` should be a float\")\nif not 0.0 &lt;= percentage &lt;= 1.0:\nraise ValueError(\"`percentage` should be between 0 and 1\")\nif not callable(logging_fn):\nraise TypeError(\"`logging_fn` should be a callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\n_, hard = resource.getrlimit(resource.RLIMIT_AS)\nfree_memory = _get_free_memory() * 1024\nlogging_fn(\nf\"Setting memory limit for {func.__name__} to {int(free_memory * percentage)}\"\n)\nresource.setrlimit(resource.RLIMIT_AS, (int(free_memory * percentage), hard))\ntry:\nreturn func(*args, **kwargs)\nexcept MemoryError:\nraise MemoryError(\"Reached memory limit\")\nfinally:\nresource.setrlimit(resource.RLIMIT_AS, (int(free_memory), hard))\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.multi_shape_tracker","title":"<code>multi_shape_tracker(func=None, shapes_in=None, shapes_out='all', raise_if_empty='any', logging_fn=LOGGING_FN)</code>","text":"<p>Tracks the shape(s) of a dataframe/array-like objects both in input and output of a given function.</p> <p>This decorator differs from <code>shape_tracker</code> in that it can track the shape of multiple arguments and outputs. In particular it can track the shape of all the arguments and outputs of a function, and raise an error if any of the tracked outputs is empty.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable[[HasShape, Sequence[Any]], Tuple[HasShape, ...]]]</code> <p>Function to decorate</p> <code>None</code> <code>shapes_in</code> <code>Optional[Union[str, int, Sequence[str], Sequence[int], None]]</code> <p>Sequence of argument positions OR argument names to track</p> <code>None</code> <code>shapes_out</code> <code>Optional[Union[int, Sequence[int], Literal['all'], None]]</code> <p>Sequence of output positions to track, \"all\" to track all, None to            disable</p> <code>'all'</code> <code>raise_if_empty</code> <code>Optional[Literal['any', 'all', None]]</code> <p>Raise error if tracked output results is/are empty             (strategy: \"any\", \"all\", None)</p> <code>'any'</code> <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if any of the parameters is not of the correct type</p> <code>EmptyShapeError</code> <p>if decorated function output is empty and <code>raise_if_empty</code> is            <code>all</code> or <code>any</code></p> <p>Usage: <pre><code>import numpy as np\nfrom deczoo import multi_shape_tracker\n@multi_shape_tracker(shapes_in=(0, 1), shapes_out=\"all\")\ndef add_mult(a: np.ndarray, b: np.ndarray) -&gt; Tuple[np.ndarray, ...]:\nreturn a + b, a * b, a@b.T\na = b = np.ones((1, 2))\n_ = add_mult(a, b)\n# Input shapes: a.shape=(1, 2) b.shape=(1, 2)\n# Output shapes: (1, 2) (1, 2) (1, 1)\n</code></pre> <code>@multi_shape_tracker(shapes_in=(0, 1), shapes_out=\"all\")</code> is equivalent to <code>@multi_shape_tracker(shapes_in=(\"a\", \"b\"), shapes_out=(0, 1, 2))</code>. However we can choose to track a subset of inputs and outputs by using the <code>shapes_in</code> and <code>shapes_out</code> parameters. This is particularly useful when some inputs/outputs are not dataframe/array-like objects.</p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef multi_shape_tracker(\nfunc: Optional[Callable[[HasShape, Sequence[Any]], Tuple[HasShape, ...]]] = None,\nshapes_in: Optional[Union[str, int, Sequence[str], Sequence[int], None]] = None,\nshapes_out: Optional[Union[int, Sequence[int], Literal[\"all\"], None]] = \"all\",\nraise_if_empty: Optional[Literal[\"any\", \"all\", None]] = \"any\",\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Tracks the shape(s) of a dataframe/array-like objects both in input and output of\n    a given function.\n    This decorator differs from `shape_tracker` in that it can track the shape of\n    multiple arguments and outputs. In particular it can track the shape of all the\n    arguments and outputs of a function, and raise an error if _any_ of the tracked\n    outputs is empty.\n    Arguments:\n        func: Function to decorate\n        shapes_in: Sequence of argument positions OR argument names to track\n        shapes_out: Sequence of output positions to track, \"all\" to track all, None to\\\n            disable\n        raise_if_empty: Raise error if tracked output results is/are empty \\\n            (strategy: \"any\", \"all\", None)\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n    Returns:\n        Decorated function\n    Raises:\n        TypeError: if any of the parameters is not of the correct type\n        EmptyShapeError: if decorated function output is empty and `raise_if_empty` is\\\n            `all` or `any`\n    Usage:\n    ```python\n    import numpy as np\n    from deczoo import multi_shape_tracker\n    @multi_shape_tracker(shapes_in=(0, 1), shapes_out=\"all\")\n    def add_mult(a: np.ndarray, b: np.ndarray) -&gt; Tuple[np.ndarray, ...]:\n        return a + b, a * b, a@b.T\n    a = b = np.ones((1, 2))\n    _ = add_mult(a, b)\n    # Input shapes: a.shape=(1, 2) b.shape=(1, 2)\n    # Output shapes: (1, 2) (1, 2) (1, 1)\n    ```\n    `@multi_shape_tracker(shapes_in=(0, 1), shapes_out=\"all\")` is equivalent to\n    `@multi_shape_tracker(shapes_in=(\"a\", \"b\"), shapes_out=(0, 1, 2))`.\n    However we can choose to track a subset of inputs and outputs by using the\n    `shapes_in` and `shapes_out` parameters. This is particularly useful when\n    some inputs/outputs are not dataframe/array-like objects.\n    \"\"\"\nif not callable(logging_fn):\nraise TypeError(\"`logging_fn` should be a callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args: Any, **kwargs: Any) -&gt; HasShape:\nfunc_args = (\ninspect.signature(func).bind(*args, **kwargs).arguments  # type: ignore\n)\n# parse shapes_in\n# case: str\nif isinstance(shapes_in, str):\n_arg_names, _arg_values = shapes_in, func_args[shapes_in]\n# case: int\nelif isinstance(shapes_in, int) and shapes_in &gt;= 0:\n_arg_names, _arg_values = tuple(\nx for x in tuple(func_args.items())[shapes_in]\n)\n# case: sequence\nelif isinstance(shapes_in, Sequence):\n# case: sequence of str's\nif all(isinstance(x, str) for x in shapes_in):\n_arg_names, _arg_values = tuple(shapes_in), tuple(  # type: ignore\nfunc_args[x] for x in shapes_in  # type: ignore\n)\n# case: sequence of positive int's\nelif all(isinstance(x, int) and x &gt;= 0 for x in shapes_in):\n_arg_names, _arg_values = zip(  # type: ignore\n*(tuple(func_args.items())[x] for x in shapes_in)  # type: ignore\n)\n# case: sequence of something else! (raise error)\nelse:\nraise TypeError(\"`shapes_in` values must all be str or positive int\")\n# case: None\nelif shapes_in is None:\npass\n# case: something else, not in Union[int, str, Sequence[int], Sequence[str], None]\nelse:\nraise TypeError(\n\"`shapes_in` must be either a str, a positive int, a sequence of str's, \\\n                    a sequence of positive int's or None\"\n)\nif shapes_in is not None:\nlogging_fn(\n\"Input shapes: \"\n+ \" \".join(\nf\"{k}.shape={v.shape}\" for k, v in zip(_arg_names, _arg_values)\n)\n)\n# finally run the function!\norig_res = func(*args, **kwargs)  # type: ignore\n# Check if the function returns a single value or a tuple\nres = (orig_res,) if not isinstance(orig_res, Sequence) else orig_res\n# parse shapes_out\n# case: positive int\nif isinstance(shapes_out, int) and shapes_out &gt;= 0:\n_res_shapes = (res[shapes_out].shape,)\n# case: sequence of positive int's\nelif isinstance(shapes_out, Sequence) and all(\nisinstance(x, int) and x &gt;= 0 for x in shapes_out\n):\n_res_shapes = tuple(res[x].shape for x in shapes_out)  # type: ignore\n# case: \"all\"\nelif shapes_out == \"all\":\n_res_shapes = tuple(x.shape for x in res)  # type: ignore\n# case: None\nelif shapes_out is None:\npass\n# case: something else, not in Union[int, Sequence[int], Literal[\"all\"], None]\nelse:\nraise TypeError(\n\"`shapes_out` must be positive int, sequence of positive int, 'all' \\\n                    or None\"\n)\nif shapes_out is not None:\nlogging_fn(\"Output shapes: \" + \" \".join(f\"{s}\" for s in _res_shapes))\n# parse raise_if_empty\nif (shapes_out is None) and (raise_if_empty is not None):  # type: ignore\n_raise_if_empty = None\nlogging_fn(\n\"Overwriting `raise_if_empty` to None because `shapes_out` \\\n                is None. Please specify `shapes_out` if you want to use `raise_if_empty`\"\n)\nelse:\n_raise_if_empty = raise_if_empty\n# case: None\nif _raise_if_empty is None:\npass\n# case: \"any\"\nelif _raise_if_empty == \"any\":\nif any(x[0] == 0 for x in _res_shapes):\nraise EmptyShapeError(\nf\"At least one result from {func.__name__} is empty\"  # type: ignore\n)\n# case: \"all\"\nelif _raise_if_empty == \"all\":\nif all(x[0] == 0 for x in _res_shapes):\nraise EmptyShapeError(\nf\"All results from {func.__name__} are empty\"  # type: ignore\n)\n# case: something else, not in Union[Literal[\"any\"], Literal[\"all\"], None]\nelse:\nraise TypeError(\"raise_if_empty must be either 'any', 'all' or None\")\nreturn orig_res  # type: ignore\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.notify_on_end","title":"<code>notify_on_end(func=None, notifier=None)</code>","text":"<p>Notify when func has finished running using the notifier <code>notify</code> method.</p> <p><code>notifier</code> object should inherit from BaseNotifier and implement any custom <code>notify</code> method.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable</code> <p>Function to decorate</p> <code>None</code> <code>notifier</code> <code>BaseNotifier</code> <p>Instance of a Notifier that implements <code>notify</code> method</p> <code>None</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Usage: <pre><code>from deczoo import notify_on_end\nfrom deczoo._base_notifier import BaseNotifier\nclass DummyNotifier(BaseNotifier):\ndef notify(self):\nprint(\"Function has finished\")\nnotifier = DummyNotifier()\n@notify_on_end(notifier=notifier)\ndef add(a, b): return a + b\n_ = add(1, 2)\n# Function has finished\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef notify_on_end(func: Callable = None, notifier: BaseNotifier = None) -&gt; Callable:\n\"\"\"\n    Notify when func has finished running using the notifier `notify` method.\n    `notifier` object should inherit from BaseNotifier and implement any custom `notify`\n    method.\n    Arguments:\n        func: Function to decorate\n        notifier: Instance of a Notifier that implements `notify` method\n    Returns:\n        Decorated function\n    Usage:\n    ```python\n    from deczoo import notify_on_end\n    from deczoo._base_notifier import BaseNotifier\n    class DummyNotifier(BaseNotifier):\n        def notify(self):\n            print(\"Function has finished\")\n    notifier = DummyNotifier()\n    @notify_on_end(notifier=notifier)\n    def add(a, b): return a + b\n    _ = add(1, 2)\n    # Function has finished\n    ```\n    \"\"\"\nif not isinstance(notifier, BaseNotifier):\nraise TypeError(\"`notifier` should be an instance of a BaseNotifier\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\ntry:\nreturn func(*args, **kwargs)\nexcept Exception as e:\nraise e\nfinally:\nnotifier.notify()\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.retry","title":"<code>retry(func=None, n_tries=3, delay=0.0, logging_fn=LOGGING_FN)</code>","text":"<p>Wraps a function within a \"retry\" block. If the function fails, it will be retried <code>n_tries</code> times with a delay of <code>delay</code> seconds between each attempt.</p> <p>The function will be retried until it succeeds or the maximum number of attempts is reached. Either the first successful result will be returned or the last error will be raised.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>n_tries</code> <code>int</code> <p>Max number of attempts to try</p> <code>3</code> <code>delay</code> <code>float</code> <p>Time to wait before a retry</p> <code>0.0</code> <code>logging_fn</code> <code>Callable</code> <p>Log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>n_tries</code> is not a positive integer, <code>delay</code> is not a             positive number, or <code>logging_fn</code> is not a callable</p> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Usage: <pre><code>from deczoo import retry\n@retry(n_tries=2, delay=1.)\ndef add(a, b): return a+b\n_ = add(1, 2)\n# Attempt 1/2: Successed\n_ = add(1, \"a\")\n# Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n# Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef retry(\nfunc: Optional[Callable] = None,\nn_tries: int = 3,\ndelay: float = 0.0,\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Wraps a function within a \"retry\" block. If the function fails, it will be retried\n    `n_tries` times with a delay of `delay` seconds between each attempt.\n    The function will be retried until it succeeds or the maximum number of attempts\n    is reached. Either the first successful result will be returned or the last error\n    will be raised.\n    Arguments:\n        func: Function to decorate\n        n_tries: Max number of attempts to try\n        delay: Time to wait before a retry\n        logging_fn: Log function (e.g. print, logger.info, rich console.print)\n    Raises:\n        ValueError: If `n_tries` is not a positive integer, `delay` is not a \\\n            positive number, or `logging_fn` is not a callable\n    Returns:\n        Decorated function\n    Usage:\n    ```python\n    from deczoo import retry\n    @retry(n_tries=2, delay=1.)\n    def add(a, b): return a+b\n    _ = add(1, 2)\n    # Attempt 1/2: Successed\n    _ = add(1, \"a\")\n    # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n    # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n    ```\n    \"\"\"\nif not isinstance(n_tries, int) or n_tries &lt; 1:\nraise ValueError(\"`n_tries` should be a positive integer\")\nif not isinstance(delay, (int, float)) or delay &lt; 0:\nraise ValueError(\"`delay` should be a positive number\")\nif not callable(logging_fn):\nraise TypeError(\"`logging_fn` should be a callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\nattempt = 0\nwhile attempt &lt; n_tries:\ntry:\nres = func(*args, **kwargs)\nlogging_fn(f\"Attempt {attempt+1}/{n_tries}: Successed\")\nreturn res\nexcept Exception as e:\nlogging_fn(f\"Attempt {attempt+1}/{n_tries}: Failed with error: {e}\")\ntime.sleep(delay)\nattempt += 1\nif attempt == n_tries:\nraise e\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.shape_tracker","title":"<code>shape_tracker(func=None, shape_in=False, shape_out=True, shape_delta=False, raise_if_empty=True, arg_to_track=0, logging_fn=LOGGING_FN)</code>","text":"<p>Tracks the shape of a dataframe/array-like object. It's possible to track input and output shape(s), delta from input and output, and raise an error if resulting output is empty.</p> <p>This is particularly suitable to decorate functions that are used in a (pandas/polars/dask/...) pipe(line).</p> <p>The decorator will track the shape of the first argument of the function, unless <code>arg_to_track</code> is specified.</p> <p>If <code>arg_to_track</code> can be:</p> <ul> <li>a non-negative integer corresponding to the index of the argument to track</li> <li>a string indicating the name of the argument to track.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable[[HasShape, Sequence[Any]], HasShape]]</code> <p>Function to decorate</p> <code>None</code> <code>shape_in</code> <code>bool</code> <p>Track input shape</p> <code>False</code> <code>shape_out</code> <code>bool</code> <p>Track output shape</p> <code>True</code> <code>shape_delta</code> <code>bool</code> <p>Track shape delta between input and output</p> <code>False</code> <code>raise_if_empty</code> <code>bool</code> <p>Raise error if output is empty</p> <code>True</code> <code>arg_to_track</code> <code>Optional[Union[int, str]]</code> <p>Index or name of the argument to track, used only if <code>shape_in</code> is            <code>True</code></p> <code>0</code> <code>logging_fn</code> <code>Callable</code> <p>Log function (e.g. print, logger.info, rich console.print)</p> <code>LOGGING_FN</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>if any of the parameters is not of the correct type</p> <code>EmptyShapeError</code> <p>if decorated function output is empty and <code>raise_if_empty</code> is            <code>True</code></p> <p>Usage: <pre><code>import numpy as np\nfrom deczoo import shape_tracker\n@shape_tracker(shape_in=True, shape_out=True, shape_delta=True, raise_if_empty=True)\ndef tracked_vstack(a: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\nreturn np.vstack([a, b])\n_ = tracked_vstack(np.ones((1, 2)), np.ones((10, 2)))\n# Input: `a` has shape (1, 2)\n# Output: result has shape (11, 2)\n# Shape delta: (-10, 0)\n_ = tracked_vstack(np.ones((0, 2)), np.ones((0, 2)))\n# Input: `a` has shape (0, 2)\n# Output: result has shape (0, 2)\n# Shape delta: (0, 0)\n&gt; EmptyShapeError: Result from tracked_vstack is empty\n</code></pre></p> <p>Now if the array to track is not the first argument, we can explicitely set <code>arg_to_track</code> to the value of 1 or \"b\".</p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef shape_tracker(\nfunc: Optional[Callable[[HasShape, Sequence[Any]], HasShape]] = None,\nshape_in: bool = False,\nshape_out: bool = True,\nshape_delta: bool = False,\nraise_if_empty: bool = True,\narg_to_track: Optional[Union[int, str]] = 0,\nlogging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n\"\"\"\n    Tracks the shape of a dataframe/array-like object.\n    It's possible to track input and output shape(s), delta from input and output, and\n    raise an error if resulting output is empty.\n    This is particularly suitable to decorate functions that are used in a\n    (pandas/polars/dask/...) pipe(line).\n    The decorator will track the shape of the first argument of the function, unless\n    `arg_to_track` is specified.\n    If `arg_to_track` can be:\n    - a non-negative integer corresponding to the index of the argument to track\n    - a string indicating the name of the argument to track.\n    Parameters:\n        func: Function to decorate\n        shape_in: Track input shape\n        shape_out: Track output shape\n        shape_delta: Track shape delta between input and output\n        raise_if_empty: Raise error if output is empty\n        arg_to_track: Index or name of the argument to track, used only if `shape_in` is\\\n            `True`\n        logging_fn: Log function (e.g. print, logger.info, rich console.print)\n    Returns:\n        Decorated function\n    Raises:\n        TypeError: if any of the parameters is not of the correct type\n        EmptyShapeError: if decorated function output is empty and `raise_if_empty` is\\\n            `True`\n    Usage:\n    ```python\n    import numpy as np\n    from deczoo import shape_tracker\n    @shape_tracker(shape_in=True, shape_out=True, shape_delta=True, raise_if_empty=True)\n    def tracked_vstack(a: np.ndarray, b: np.ndarray) -&gt; np.ndarray:\n        return np.vstack([a, b])\n    _ = tracked_vstack(np.ones((1, 2)), np.ones((10, 2)))\n    # Input: `a` has shape (1, 2)\n    # Output: result has shape (11, 2)\n    # Shape delta: (-10, 0)\n    _ = tracked_vstack(np.ones((0, 2)), np.ones((0, 2)))\n    # Input: `a` has shape (0, 2)\n    # Output: result has shape (0, 2)\n    # Shape delta: (0, 0)\n    &gt; EmptyShapeError: Result from tracked_vstack is empty\n    ```\n    Now if the array to track is not the first argument, we can explicitely set\n    `arg_to_track` to the value of 1 or \"b\".\n    \"\"\"\nif not isinstance(shape_in, bool):\nraise TypeError(\"`shape_in` should be a boolean\")\nif not isinstance(shape_out, bool):\nraise TypeError(\"`shape_out` should be a boolean\")\nif not isinstance(shape_delta, bool):\nraise TypeError(\"`shape_delta` should be a boolean\")\nif not isinstance(raise_if_empty, bool):\nraise TypeError(\"`raise_if_empty` should be a boolean\")\nif (not isinstance(arg_to_track, (str, int))) or (\nisinstance(arg_to_track, int) and arg_to_track &lt; 0\n):\nraise TypeError(\"`arg_to_track` should be a string or a positive integer\")\nif not callable(logging_fn):\nraise TypeError(\"`logging_fn` should be a callable\")\n@wraps(func)  # type: ignore\ndef wrapper(*args: Any, **kwargs: Any) -&gt; HasShape:\nfunc_args = (\ninspect.signature(func).bind(*args, **kwargs).arguments  # type: ignore\n)\nif isinstance(arg_to_track, int) and arg_to_track &gt;= 0:\n_arg_name, _arg_value = tuple(func_args.items())[arg_to_track]\nelif isinstance(arg_to_track, str):\n_arg_name, _arg_value = arg_to_track, func_args[arg_to_track]\nelse:\nraise ValueError(\"arg_to_track should be a string or a positive integer\")\nif shape_in:\nlogging_fn(f\"Input: `{_arg_name}` has shape {_arg_value.shape}\")\nres = func(*args, **kwargs)  # type: ignore\noutput_shape = res.shape\nif shape_out:\nlogging_fn(f\"Output: result has shape {output_shape}\")\nif shape_delta:\ninput_shape = _arg_value.shape\ndelta = tuple(\nd1 - d2 for d1, d2 in zip_longest(input_shape, output_shape, fillvalue=0)\n)\nlogging_fn(f\"Shape delta: {delta}\")\nif raise_if_empty and output_shape[0] == 0:\nraise EmptyShapeError(f\"Result from {func.__name__} is empty\")  # type: ignore\nreturn res\nreturn wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.timeout","title":"<code>timeout(func=None, time_limit=None, signal_handler=None, signum=signal.SIGALRM)</code>","text":"<p>Sets a time limit to a function, terminates the process if it hasn't finished within such time limit.</p> <p>Warning: This decorator uses the built-in signal library which fully supported only on UNIX.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Optional[Callable]</code> <p>Function to decorate</p> <code>None</code> <code>time_limit</code> <code>Optional[int]</code> <p>Max time (in seconds) for function to run, 0 means no time limit</p> <code>None</code> <code>signal_handler</code> <code>Optional[Callable]</code> <p>Custom signal handler raising a TimeoutError</p> <code>None</code> <code>signum</code> <code>Union[int, Enum]</code> <p>Signal number to be used, default=signal.SIGALRM (14)</p> <code>signal.SIGALRM</code> <p>Returns:</p> Type Description <code>Callable</code> <p>Decorated function</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>time_limit</code> is not a positive number</p> <code>TypeError</code> <p>If <code>signum</code> is not an int or an Enum, or if <code>signal_handler</code> is not a             callable</p> <code>TimeoutError</code> <p>If <code>time_limit</code> is reached without decorated function finishing</p> <p>Usage: <pre><code>import time\nfrom deczoo import timeout\n@timeout(time_limit=3)\ndef add(a, b):\ntime.sleep(2)\nreturn a+b\nadd(1, 2)\n3\n@timeout(time_limit=1)\ndef add(a, b):\ntime.sleep(2)\nreturn a+b\nadd(1, 2)\n&gt; TimeoutError: Reached time limit, terminating add\n</code></pre></p> Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef timeout(\nfunc: Optional[Callable] = None,\ntime_limit: Optional[int] = None,\nsignal_handler: Optional[Callable] = None,\nsignum: Union[int, Enum] = signal.SIGALRM,\n) -&gt; Callable:\n\"\"\"\n    Sets a time limit to a function, terminates the process if it hasn't finished within\n    such time limit.\n    **Warning**: This decorator uses the built-in\n    [signal library](https://docs.python.org/3/library/signal.html) which fully supported\n    only on UNIX.\n    Arguments:\n        func: Function to decorate\n        time_limit: Max time (in seconds) for function to run, 0 means no time limit\n        signal_handler: Custom signal handler raising a TimeoutError\n        signum: Signal number to be used, default=signal.SIGALRM (14)\n    Returns:\n        Decorated function\n    Raises:\n        ValueError: If `time_limit` is not a positive number\n        TypeError: If `signum` is not an int or an Enum, or if `signal_handler` is not a \\\n            callable\n        TimeoutError: If `time_limit` is reached without decorated function finishing\n    Usage:\n    ```python\n    import time\n    from deczoo import timeout\n    @timeout(time_limit=3)\n    def add(a, b):\n        time.sleep(2)\n        return a+b\n    add(1, 2)\n    3\n    @timeout(time_limit=1)\n    def add(a, b):\n        time.sleep(2)\n        return a+b\n    add(1, 2)\n    &gt; TimeoutError: Reached time limit, terminating add\n    ```\n    \"\"\"\nif (not isinstance(time_limit, int)) or time_limit &lt; 0:\nraise ValueError(\"`time_limit` should be a strictly positive number\")\nif not isinstance(signum, (int, Enum)):\nraise TypeError(\"`signum` should be an int or an Enum\")\nif signal_handler is None:\ndef signal_handler(signum, frame):\nraise TimeoutError(f\"Reached time limit, terminating {func.__name__}\")\nsignal.signal(signum, signal_handler)  # type: ignore\nelif not callable(signal_handler):\nraise TypeError(\"`signal_handler` should be a callable\")\nelse:\n# custome signal handler provided -&gt; bind it to the signal\nsignal.signal(signum, signal_handler)  # type: ignore\n@wraps(func)  # type: ignore\ndef wrapper(*args, **kwargs):\nsignal.alarm(time_limit)\ntry:\nres = func(*args, **kwargs)\nreturn res\nexcept TimeoutError as e:\nraise e\nexcept Exception as e:\nraise e\nfinally:\nsignal.alarm(0)\nreturn wrapper\n</code></pre>"},{"location":"api/utils/","title":"Utility functions","text":""},{"location":"api/utils/#deczoo._utils.check_parens","title":"<code>check_parens(decorator)</code>","text":"<p>Check whether or not a decorator function gets called with parens:</p> <ul> <li>If called with parens, the decorator is called without the function as the first     argument, but necessarely with decorator keyword arguments.</li> <li>If called without parens, the decorator is called with the function as the first     argument, and the decorator's default arguments.</li> </ul> <p>This function is used internally to endow every decorator of the above property.</p> <p>Parameters:</p> Name Type Description Default <code>decorator</code> <code>Callable</code> <p>decorator to wrap</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Wrapped decorator.</p> <p>Usage: <pre><code>@check_parens\ndef decorator(func, k1=\"default1\", k2=\"default2\"):\n# where the magic happens\n...\n# `decorator` called without parens, hence default params.\n@decorator\ndef func(*func_args, **func_kwargs):\npass\n# `decorator` called with custom params, necessarely using parens.\n@decorator(*args, **kwargs)\ndef func(*func_args, **func_kwargs):\npass\n</code></pre></p> Source code in <code>deczoo/_utils.py</code> <pre><code>def check_parens(decorator: Callable) -&gt; Callable:\n\"\"\"\n    Check whether or not a decorator function gets called with parens:\n    - If called with parens, the decorator is called without the function as the first\n        argument, but necessarely with decorator keyword arguments.\n    - If called without parens, the decorator is called with the function as the first\n        argument, and the decorator's default arguments.\n    This function is used internally to endow every decorator of the above property.\n    Arguments:\n        decorator: decorator to wrap\n    Returns:\n        Wrapped decorator.\n    Usage:\n    ```python\n    @check_parens\n    def decorator(func, k1=\"default1\", k2=\"default2\"):\n        # where the magic happens\n        ...\n    # `decorator` called without parens, hence default params.\n    @decorator\n    def func(*func_args, **func_kwargs):\n        pass\n    # `decorator` called with custom params, necessarely using parens.\n    @decorator(*args, **kwargs)\n    def func(*func_args, **func_kwargs):\n        pass\n    ```\n    \"\"\"\n@wraps(decorator)\ndef wrapper(func: Callable = None, *args, **kwargs) -&gt; Callable:\nif func is None:\nreturn partial(decorator, *args, **kwargs)\nelse:\nreturn decorator(func, *args, **kwargs)\nreturn wrapper\n</code></pre>"},{"location":"api/utils/#deczoo._utils._get_free_memory","title":"<code>_get_free_memory()</code>","text":"<p>Computes machine free memory via <code>/proc/meminfo</code> file (linux only).</p> <p>Warning: This functionality is supported on unix-based systems only!</p> Source code in <code>deczoo/_utils.py</code> <pre><code>def _get_free_memory() -&gt; int:\n\"\"\"\n    Computes machine free memory via `/proc/meminfo` file (linux only).\n    **Warning**: This functionality is supported on unix-based systems only!\n    \"\"\"\nwith open(\"/proc/meminfo\", \"r\") as mem:\nfree_memory = 0\nfor i in mem:\nsline = i.split()\nif str(sline[0]) in (\"MemFree:\", \"Buffers:\", \"Cached:\"):\nfree_memory += int(sline[1])\nreturn free_memory\n</code></pre>"},{"location":"decorators/advanced/","title":"Advanced Usage","text":""},{"location":"decorators/advanced/#wraps","title":"Wraps","text":"<p><code>functools.wraps</code> is a utility function in the Python standard library that is often used in decorators to preserve the original function's metadata (such as its name, docstring, and annotations) in the wrapper function.</p> <p>Here's an example of how <code>functools.wraps</code> can be used in a decorator, and how the metadata's differ:</p> with @wrapswithout @wraps <pre><code>from functools import wraps\ndef dec_with_wraps(func):\n@wraps(func)\ndef wrapper(*args, **kwargs):\n# Do something before the function is called\nresult = func(*args, **kwargs)\n# Do something after the function is called\nreturn result\nreturn wrapper\n@dec_with_wraps\ndef my_func():\n\"\"\"This is my function\"\"\"\nreturn \"Hello, world!\"\nprint(f\"Name = '{my_func.__name__}'\", f\"Docs = '{my_func.__doc__}'\", sep=\"\\n\")\n# Name = 'my_func'\n# Docs = 'This is my function'\n</code></pre> <pre><code>def dec_no_wraps(func):\ndef wrapper(*args, **kwargs):\n# Do something before the function is called\nresult = func(*args, **kwargs)\n# Do something after the function is called\nreturn result\nreturn wrapper\n@dec_no_wraps\ndef my_func():\n\"\"\"This is my function\"\"\"\nreturn \"Hello, world!\"\nprint(f\"Name = '{my_func.__name__}'\", f\"Docs = '{my_func.__doc__}'\", sep=\"\\n\")\n# Name = 'wrapper'\n# Docs = 'None'\n</code></pre> <p>As you can see, the two decorators <code>dec_with_wraps</code> and <code>dec_no_wraps</code> are indentical; the only difference between the two cases is the use of <code>@wraps</code> decorator in the former to preserve the metadata of the original function.</p> <p>When we print the <code>__name__</code> and <code>__doc__</code> attributes of the function in the two different scenarios, we obtain completely different results! In particular, in the first case the metadata of the decorated <code>my_func</code> are maintained, in the latter the metadata we obtain are those of the <code>wrapper</code> function inside the decorator.</p>"},{"location":"decorators/advanced/#decorators-with-arguments","title":"Decorators with arguments","text":"<p>Sometimes we have more complexity to model and to achieve that we need to be able to pass arguments to our decorator.</p> <p>Let's assume that we want to run a function twice, or 3-times, or 4-times and so on.</p> <p>Instead of writing differnt decorators that run the input function N times, we can go one level deeper, and define a function that takes the decorator arguments and returns the actual decorator function.</p> repeat_n_times<pre><code>from functools import wraps\nfrom typing import Callable\ndef repeat_n_times(n: int) -&gt; Callable:\n\"\"\"Gets as input the arguments to be used in the actual decorator\"\"\"\ndef decorator(func: Callable) -&gt; Callable:\n\"\"\"This is the actual decorator!\"\"\"\n@wraps(func)\ndef wrapper(*args, **kwargs):\n\"\"\"Returns a list with N func results\"\"\"\nreturn [func(*args, **kwargs) for _ in range(n)]\nreturn wrapper\nreturn decorator\n@repeat_n_times(n=2)\ndef say_hello(name: str) -&gt; str:\nreturn f\"Hello {name}!\"\nprint(say_hello(\"Fra\"))\n# ['Hello Fra!', 'Hello Fra!']\n</code></pre> <p></p> <p>Do you feel confused? If the answer is yes, it is because it is kinda confusing!</p> <p>A decorator with arguments is a function that takes arguments and returns another function that acts as the actual decorator.</p> <p>This decorator function takes a function as an argument and returns a new function that modifies the original function in some way.</p> <p>The key difference between a decorator with arguments and a regular decorator is that the decorator with arguments has an extra layer of nested functions. The outer function takes the arguments and returns the actual decorator function, while the inner function takes the original function as an argument and returns the modified function.</p> <p>Remark that even if we define <code>repeat_n_times</code> to have a default value for <code>n</code>, when we decorate a function we need to call the decorator, since that returns the actual decorator that we want, namely we need to:</p> <pre><code>def repeat_n_times(n: int = 3) -&gt; Callable:\n...\n@repeat_n_times()\ndef say_hello(name: str) -&gt; str:\nreturn f\"Hello {name}!\"\n@repeat_n_times\ndef say_goodbye(name: str) -&gt; str:\nreturn f\"Goodbye {name}!\"\nprint(say_hello(\"Fra\"))\n# ['Hello Fra!', 'Hello Fra!', 'Hello Fra!']\nprint(say_goodbye(\"Fra\"))\n# &lt;function __main__.repeat_n_times.&lt;locals&gt;.decorator.&lt;locals&gt;.wrapper&gt;\n</code></pre> <p>Which is not really what we want for the <code>say_goodbye</code> function!</p> <p>Can we do it differently??? Sure we can! And that's how all decorators in deczoo are implemented.</p>"},{"location":"decorators/advanced/#decorators-with-arguments-pt2","title":"Decorators with arguments, pt.2","text":"<p>In the introduction we saw how a decorator is defined, let's stuck to such implementation but let's see how to add additional parameters and control flow without the need to have more level of indentation.</p> <p>Here is a different impementation of <code>repeat_n_times</code>, this time without a triple level of indentation:</p> repeat_n_times definition<pre><code>from functools import wraps, partial\nfrom typing import Callable\ndef repeat_n_times(func: Callable = None, n: int = 2) -&gt; Callable:\n@wraps(func)\ndef wrapper(*args, **kwargs):\nresults = [func(*args, **kwargs) for _ in range(n)]\nreturn results\nif func is None:\nreturn partial(repeat_n_times, n=n)\nelse:\nreturn wrapper\n</code></pre> <p>Let's see what happens here:</p> <ul> <li><code>repeat_n_times</code> takes as input the function to decorate (<code>func</code>) as first argument, and any additional input right after.</li> <li>To use this trick, every additional argument must have a default value (which can be <code>None</code>).</li> <li>Within the decorator we implement a <code>wrapper</code> as usual, where we use any additional decorator argument (<code>n</code> in this example).</li> <li>Since <code>wrapper</code> is not run until execution time, we can then check what is the value of <code>func</code>:<ul> <li>if it is <code>None</code>, then it means that only additional arguments have been provided to the decorator, and therefore we return a partial decorator with the given arguments that will decorate our function.</li> <li>Otherwise, the function is provided and we return the <code>wrapper</code>.</li> </ul> </li> </ul> <p>This \"trick\" allows us to use the decorator with parens, providing custom arguments, or without parens, using defaults, i.e.</p> repeat_n_times example<pre><code>@repeat_n_times(n=3)  # uses custom argument value\ndef say_hello(name: str) -&gt; str:\nreturn f\"Hello {name}!\"\n@repeat_n_times  # uses default argument value\ndef say_goodbye(name: str) -&gt; str:\nreturn f\"Goodbye {name}!\"\nprint(say_hello(\"Fra\"))\n# [\"Hello Fra!\", \"Hello Fra!\", \"Hello Fra!\"]\nprint(say_goodbye(\"Fra\"))\n# ['Goodbye Fra!', 'Goodbye Fra!']\n</code></pre> <p>Neat! This was possible to achive using the control flow and <code>partial</code> block at the end of the decorator.</p> <p>Since in deczoo every decorator is implemented using this strategy, we wrote a sort of \"meta-decorator\", called check_parens that adds such block to every decorator!</p> <pre><code>...\nif func is None:\nreturn partial(repeat_n_times, n=n)\nelse:\nreturn wrapper\n</code></pre>"},{"location":"decorators/intro/","title":"Introduction","text":""},{"location":"decorators/intro/#what-is-a-decorator","title":"What is a decorator?","text":"<p>In Python, a decorator is a way to modify or enhance the behavior of a function or a class without actually modifying the source code of the function or class.</p> <p>Decorators are implemented as functions (or classes) that take a function or a class as input and return a new function or class that has some additional functionality.</p> <p>Here is a simple example in order to illustrate the concept:</p> <pre><code>from typing import Callable\ndef my_decorator(func: Callable) -&gt; Callable:\n\"\"\"\n    - `func` is the function taken as input to our decorator\n    - `func` behaviour will be modified/enhanced\n    - `wrapper` is the function that the decorator returns\n    \"\"\"\ndef wrapper(*args, **kwargs):\nprint(f\"Starting to run {func.__name__}\")\nres = func(*args, **kwargs)\nprint(f\"{func.__name__} finished running!\")\nreturn res\nreturn wrapper\n</code></pre> <p>Here, <code>my_decorator</code> is a function that takes a function, denoted as <code>func</code> here, as input and returns a new function called <code>wrapper</code>. In this case, <code>wrapper</code> contains some additional functionalities (in this case, the <code>print</code> statements) that are executed before and after the original function call.</p> <p><code>wrapper</code> function takes any number of positional and keyword arguments (<code>*args</code> and <code>**kwargs</code>), calls the original function <code>func</code> with those arguments, and returns the orignal result of the function call <code>res</code>.</p>"},{"location":"decorators/intro/#decorator-syntax","title":"Decorator syntax","text":"<p>We just saw what is a decorator and how to code one, but how can we use it?</p> <p>There are two equivalent options available:</p> <ul> <li> <p>The <code>@</code>-syntax (\"decorator syntax\" or \"decorator notation\"), this is a shorthand way of applying a decorator to a function or a class, without having to explicitly call the decorator function and passing the function or class as an argument:</p> <pre><code>@my_decorator\ndef my_func():\nprint(\"Hello world!\")\nreturn 42\n</code></pre> </li> <li> <p>Alternatively:</p> <pre><code>def my_func():\nprint(\"Hello world!\")\nreturn 42\nmy_func = my_decorator(my_func)\n</code></pre> </li> </ul> <p>In both cases, when calling the function we will get:</p> <pre><code>result = my_func()\n# Starting to run my_func\n# Hello world!\n# my_func finished running!\nresult\n# 42\n</code></pre>"}]}