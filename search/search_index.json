{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>  </p>"},{"location":"#deczoo","title":"Deczoo","text":"<p>A zoo for decorators</p>  <p>There are many great decorators out there that we use everyday. Why don't collect few of them?</p> <p>I found myself implementing over and over in different projects. The hope is to gather them here and use this codebase.</p>  <p>Documentation: https://fbruzzesi.github.io/deczoo</p> <p>Source Code: https://github.com/fbruzzesi/deczoo</p>"},{"location":"#alpha-notice","title":"Alpha Notice","text":"<p>This codebase is experimental and is working for my use cases. It is very probable that there are cases not covered and for which it breaks (badly). If you find them, please feel free to open an issue in the issue page of the repo.</p>"},{"location":"#installation","title":"Installation","text":"<p>deczoo is published as a Python package on pypi, and it can be installed with pip, ideally by using a virtual environment (suggested option), or directly from source using git, or with a local clone:</p> pip (pypi)source/gitlocal clone   <pre><code>python -m pip install deczoo\n</code></pre>   <pre><code>python -m pip install git+https://github.com/FBruzzesi/deczoo.git\n</code></pre>   <pre><code>git clone https://github.com/FBruzzesi/deczoo.git\ncd deczoo\npython -m pip install .\n</code></pre>"},{"location":"#license","title":"License","text":"<p>The project has a MIT Licence</p>"},{"location":"contribute/","title":"Contributing","text":""},{"location":"contribute/#guidelines","title":"Guidelines","text":"<p>We welcome contributions to the library! If you have a bug fix or new feature that you would like to contribute, please follow the steps below:</p> <ol> <li>Fork the repository on GitHub.</li> <li>Clone the repository to your local machine.</li> <li>Create a new branch for your bug fix or feature.</li> <li>Make your changes and test them thoroughly, making sure that it passes all current tests.</li> <li>Commit your changes and push the branch to your fork.</li> <li>Open a pull request on the main repository.</li> </ol>"},{"location":"contribute/#code-of-conduct","title":"Code of Conduct","text":"<p>All contributors are expected to follow the project's code of conduct, which is based on the Contributor Covenant.</p>"},{"location":"contribute/#reporting-bugs","title":"Reporting Bugs","text":"<p>If you find a bug in the library, please report it by opening an issue on GitHub. Be sure to include the version of the library you're using, as well as any error messages or tracebacks and a reproducible example.</p>"},{"location":"contribute/#requesting-features","title":"Requesting Features","text":"<p>If you have a suggestion for a new feature, please open an issue on GitHub. Be sure to explain the problem that you're trying to solve and how you think the feature would solve it.</p>"},{"location":"contribute/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>When submitting a pull request, please make sure that you've followed the steps above and that your code has been thoroughly tested. Also, be sure to include a brief summary of the changes you've made and a reference to any issues that your pull request resolves.</p>"},{"location":"contribute/#code-formatting","title":"Code formatting","text":"<p>Compclasses uses black and isort with the following  parameters for code formatting:</p> <pre><code>isort --profile black -l 90 deczoo tests\nblack --target-version py38 --line-length 90 deczoo tests\n</code></pre> <p>As part of the checks on pull requests, it is checked whether the code follows those standards. To ensure that the standard is met, it is recommanded to install pre-commit hooks:</p> <pre><code>python -m pip install pre-commit\npre-commit install\n</code></pre>"},{"location":"contribute/#developing","title":"Developing","text":"<p>Let's suppose that you already did steps 1-3 from the above list, now you should install the library and its developing dependencies  in editable way.</p> <p>First move into the repo folder: <code>cd deczoo</code>.</p> <p>Then:</p> with makewithout make   <pre><code>make init-dev\n</code></pre>   <pre><code>pip install -e \".[dev,doc]\" --no-cache-dir\npre-commit install\n</code></pre>    <p>Now you are ready to proceed with all the changes you want to!</p>"},{"location":"contribute/#testing","title":"Testing","text":"<p>Once you are done with changes, you should:</p> <ul> <li>add tests for the new features in the <code>/tests</code> folder</li> <li> <p>make sure that new features do not break existing codebase by running tests:</p> with makewithout make   <pre><code>make test\n</code></pre>   <pre><code>pytest tests -vv\n</code></pre>    </li> </ul>"},{"location":"contribute/#docs","title":"Docs","text":"<p>The documentation is generated using mkdocs-material, the API part uses mkdocstrings.</p> <p>If a breaking feature is developed, then we suggest to update documentation in the <code>/docs</code> folder as well, in order to describe how this can be used from a user perspective.</p>"},{"location":"quickstart/","title":"Getting started","text":"<p>The idea is kind of simple: each function in the library is a (function) decorator with a specific objective in mind.</p> Example: log decorator<pre><code>from deczoo import log\n\n@log # equivalent to @log(log_time=True, log_args=True, log_error=True, logging_fn=print)\ndef my_add_function(a, b, *args):\n    \"\"\"Adds all arguments together\"\"\"\n    return sum([a, b, *args])\n\n_ = my_add_function(1, 2, 3, 4)\n# my_add_function args=(a=1, b=2, args=(3, 4)) time=0:00:00.000062\n\n _ = my_add_function(1, \"a\", 2)\n# my_add_function args=(a=1, b=a, args=(2,)) time=0:00:00.000064 Failed with error: unsupported\n# operand type(s) for +: 'int' and 'str'\n</code></pre>"},{"location":"quickstart/#features","title":"Features","text":"<p>The library implements the following decorators:</p> <ul> <li><code>call_counter</code>: Counts how many times a function has been called</li> <li><code>catch</code>: Wraps a function in a try-except block</li> <li><code>check_args</code>: Checks that function arguments satisfy given rules</li> <li><code>chime_on_end</code>: Notify with chime sound on function end</li> <li><code>log</code>: Tracks function time taken, arguments and errors</li> <li><code>timer</code>: Tracks function time taken</li> <li><code>memory_limit</code>: Sets a memory limit for a function</li> <li><code>notify_on_end</code>: notifies you when a function finished with a custom notifier</li> <li><code>retry</code>: Wraps a function with a retry block</li> <li><code>timeout</code>: Sets a time limit to a function to run</li> </ul>"},{"location":"quickstart/#examples","title":"Examples","text":"<p>Please refer to the api page to see a basic example for each decorator.</p>"},{"location":"api/decorators/","title":"Available Decorators","text":""},{"location":"api/decorators/#deczoo.decorators.call_counter","title":"<code>call_counter(func=None, seed=0, log_counter=False, logging_fn=&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;)</code>","text":"<p>Counts how many times a function has been called in the <code>_calls</code> attribute</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>seed</code> <code>int</code> <p>counter start</p> <code>0</code>   <code>log_counter</code> <code>bool</code> <p>whether display count number</p> <code>False</code>   <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;</code>    <p>Exceptions:</p>    Type Description     <code>ValueError</code> <p>if seed is not an int</p>    <p>Usage:</p> <pre><code>from deczoo import call_counter\n\n@call_counter\ndef add(a, b): return a+b\n\nfor _ in range(3):\n    add(1,2)\n\nadd._calls\n3\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef call_counter(\n    func: Optional[Callable] = None,\n    seed: int = 0,\n    log_counter: bool = False,\n    logging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n    \"\"\"\n    Counts how many times a function has been called in the `_calls` attribute\n\n    Arguments:\n        func: function to decorate\n        seed: counter start\n        log_counter: whether display count number\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n\n    Raises:\n        ValueError: if seed is not an int\n\n    Usage:\n\n    ```python\n    from deczoo import call_counter\n\n    @call_counter\n    def add(a, b): return a+b\n\n    for _ in range(3):\n        add(1,2)\n\n    add._calls\n    3\n    ```\n    \"\"\"\n\n    if not isinstance(seed, int):\n        raise TypeError(\"`seed` argument must be an int\")\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        wrapper._calls += 1\n\n        if log_counter:\n            logging_fn(f\"{func.__name__} called {wrapper._calls} times\")\n\n        return func(*args, **kwargs)\n\n    # set counter dynamically\n    wrapper._calls = seed  # type: ignore\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.catch","title":"<code>catch(func=None, return_on_exception=None, raise_on_exception=None, logging_fn=&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;)</code>","text":"<p>Wraps a function in a try-except block, potentially prevent exception to be raised or raises custom exception</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>return_on_exception</code> <code>Optional[Any]</code> <p>value to return on exception</p> <code>None</code>   <code>raise_on_exception</code> <code>Optional[Any]</code> <p>error to raise on exception</p> <code>None</code>   <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;</code>    <pre><code>from deczoo import catch\n\n@catch(return_on_exception=-999)\ndef add(a, b): return a+b\n\nadd(1, 2)\n3\n\nadd(1, \"a\")\n-999\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef catch(\n    func: Optional[Callable] = None,\n    return_on_exception: Optional[Any] = None,\n    raise_on_exception: Optional[Any] = None,\n    logging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n    \"\"\"\n    Wraps a function in a try-except block,\n    potentially prevent exception to be raised or raises custom exception\n\n    Arguments:\n        func: function to decorate\n        return_on_exception: value to return on exception\n        raise_on_exception: error to raise on exception\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n\n    ```python\n    from deczoo import catch\n\n    @catch(return_on_exception=-999)\n    def add(a, b): return a+b\n\n    add(1, 2)\n    3\n\n    add(1, \"a\")\n    -999\n    ```\n    \"\"\"\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        try:\n            return func(*args, **kwargs)\n\n        except Exception as e:\n\n            if return_on_exception is not None:\n                logging_fn(f\"Failed with error {e}, returning {return_on_exception}\")\n                return return_on_exception\n\n            elif raise_on_exception is not None:\n                logging_fn(f\"Failed with error {e}\")\n                raise raise_on_exception\n\n            else:\n                logging_fn(f\"Failed with error {e}\")\n                raise e\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.check_args","title":"<code>check_args(func=None, **rules)</code>","text":"<p>Checks that function arguments satisfy given rules, if not raises a ValueError</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>rules</code> <code>Callable[[Any], bool]</code> <p>rules to be satisfied, each rule is a function that takes the argument value and returns a boolean</p> <code>{}</code>    <p>Usage:</p> <pre><code>from deczoo import check_args\n\n@check_args(a=lambda t: t&gt;0)\ndef add(a, b): return a+b\n\nadd(1,2)\n3\n\nadd(-2, 2)\n# ValueError: Argument a doesn't satisfy its rule\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef check_args(\n    func: Optional[Callable] = None, **rules: Callable[[Any], bool]\n) -&gt; Callable:\n    \"\"\"\n    Checks that function arguments satisfy given rules, if not raises a ValueError\n\n    Arguments:\n        func: function to decorate\n        rules: rules to be satisfied, each rule is a function that takes the argument value\n            and returns a boolean\n\n    Usage:\n\n    ```python\n    from deczoo import check_args\n\n    @check_args(a=lambda t: t&gt;0)\n    def add(a, b): return a+b\n\n    add(1,2)\n    3\n\n    add(-2, 2)\n    # ValueError: Argument a doesn't satisfy its rule\n    ```\n    \"\"\"\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs) -&gt; Callable:\n\n        func_args = inspect.signature(func).bind(*args, **kwargs).arguments  # type: ignore\n\n        for k, v in func_args.items():\n            rule = rules.get(k)\n\n            if rule is not None:\n\n                if not rule(v):\n                    raise ValueError(f\"Argument {k} doesn't satisfy its rule\")\n\n        res = func(*args, **kwargs)  # type: ignore\n        return res\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.chime_on_end","title":"<code>chime_on_end(func=None, theme=None)</code>","text":"<p>Notify with chime sound on function end</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>theme</code> <code>Optional[str]</code> <p>chime theme to use</p> <code>None</code>    <p>Usage:</p> <pre><code>from deczoo import chime_on_end\n\n@chime_on_end\ndef add(a, b): return a+b\n\n_ = add(1, 2)\n# you should hear a sound now!\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef chime_on_end(\n    func: Optional[Callable] = None, theme: Optional[str] = None\n) -&gt; Callable:\n    \"\"\"\n    Notify with chime sound on function end\n\n    Arguments:\n        func: function to decorate\n        theme: chime theme to use\n\n    Usage:\n\n    ```python\n    from deczoo import chime_on_end\n\n    @chime_on_end\n    def add(a, b): return a+b\n\n    _ = add(1, 2)\n    # you should hear a sound now!\n    ```\n    \"\"\"\n    chime.theme(theme)\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        try:\n            res = func(*args, **kwargs)\n            chime.success()\n            return res\n\n        except Exception as e:\n            chime.error()\n            raise e\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.log","title":"<code>log(func=None, log_time=True, log_args=True, log_error=True, log_file=None, logging_fn=&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;)</code>","text":"<p>Tracks function time taken, arguments and errors</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>log_time</code> <code>bool</code> <p>whether or not to log time taken</p> <code>True</code>   <code>log_args</code> <code>bool</code> <p>whether or not to log arguments</p> <code>True</code>   <code>log_error</code> <code>bool</code> <p>whether or not to log error</p> <code>True</code>   <code>log_file</code> <code>Optional[str]</code> <p>filepath where to write log</p> <code>None</code>   <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;</code>    <p>Usage:</p> <pre><code>from deczoo import log\n\n@log\ndef add(a, b): return a+b\n\n_ = add(1, 2)\n# add args=(a=1, b=2) time=0:00:00.000111\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef log(\n    func: Optional[Callable] = None,\n    log_time: bool = True,\n    log_args: bool = True,\n    log_error: bool = True,\n    log_file: Optional[str] = None,\n    logging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n    \"\"\"\n    Tracks function time taken, arguments and errors\n\n    Arguments:\n        func: function to decorate\n        log_time: whether or not to log time taken\n        log_args: whether or not to log arguments\n        log_error: whether or not to log error\n        log_file: filepath where to write log\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n\n    Usage:\n\n    ```python\n    from deczoo import log\n\n    @log\n    def add(a, b): return a+b\n\n    _ = add(1, 2)\n    # add args=(a=1, b=2) time=0:00:00.000111\n    ```\n    \"\"\"\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        tic = time.perf_counter()\n\n        if log_args:\n\n            func_args = inspect.signature(func).bind(*args, **kwargs).arguments\n            func_args_str = \", \".join(f\"{k}={v}\" for k, v in func_args.items())\n\n            optional_strings = [f\"args=({func_args_str})\"]\n\n        else:\n            optional_strings = []\n\n        try:\n            res = func(*args, **kwargs)\n            toc = time.perf_counter()\n            optional_strings += [\n                f\"time={toc - tic}\" if log_time else None,\n            ]\n\n            return res\n\n        except Exception as e:\n\n            toc = time.perf_counter()\n            optional_strings += [\n                f\"time={toc - tic}\" if log_time else None,\n                \"Failed\" + (f\" with error: {e}\" if log_error else \"\"),\n            ]\n            raise e\n\n        finally:\n            log_string = f\"{func.__name__} {' '.join([s for s in optional_strings if s])}\"\n            logging_fn(log_string)\n\n            if log_file is not None:\n\n                with open(log_file, \"a\") as f:\n                    f.write(f\"{tic} {log_string}\\n\")\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.memory_limit","title":"<code>memory_limit(func=None, percentage=0.99, logging_fn=&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;)</code>","text":"<p>Sets a memory limit for a function</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>percentage</code> <code>float</code> <p>percentage of the currently available memory to use</p> <code>0.99</code>   <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;</code>    <p>Usage:</p> <pre><code>from deczoo import memory_limit\n\n# Running on WSL2 with 12 Gb RAM\n\n@memory_limit(percentage=0.2)\ndef limited():\n    for i in list(range(10 ** 8)):\n        _ = 1 + 1\n    return \"done\"\n\ndef unlimited():\n    for i in list(range(10 ** 8)):\n        _ = 1 + 1\n    return \"done\"\n\nlimited()\n# MemoryError: Reached memory limit\n\nunlimited()\ndone\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef memory_limit(\n    func: Optional[Callable] = None,\n    percentage: float = 0.99,\n    logging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n    \"\"\"\n    Sets a memory limit for a function\n\n    Arguments:\n        func: function to decorate\n        percentage: percentage of the currently available memory to use\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n\n    Usage:\n\n    ```python\n    from deczoo import memory_limit\n\n    # Running on WSL2 with 12 Gb RAM\n\n    @memory_limit(percentage=0.2)\n    def limited():\n        for i in list(range(10 ** 8)):\n            _ = 1 + 1\n        return \"done\"\n\n    def unlimited():\n        for i in list(range(10 ** 8)):\n            _ = 1 + 1\n        return \"done\"\n\n    limited()\n    # MemoryError: Reached memory limit\n\n    unlimited()\n    done\n    ```\n    \"\"\"\n    if not isinstance(percentage, float):\n        raise TypeError(\"percentage should be a float\")\n\n    if not 0 &lt;= percentage &lt;= 1:\n        raise ValueError(\"percentage should be between 0 and 1\")\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        _, hard = resource.getrlimit(resource.RLIMIT_AS)\n        free_memory = _get_free_memory() * 1024\n\n        logging_fn(\n            f\"Setting memory limit for {func.__name__} to {int(free_memory * percentage)}\"\n        )\n\n        resource.setrlimit(resource.RLIMIT_AS, (int(free_memory * percentage), hard))\n\n        try:\n            return func(*args, **kwargs)\n\n        except MemoryError:\n            raise MemoryError(\"Reached memory limit\")\n\n        finally:\n            resource.setrlimit(resource.RLIMIT_AS, (int(free_memory), hard))\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.notify_on_end","title":"<code>notify_on_end(func=None, notifier=None)</code>","text":"<p>Notify when func has finished running using the notifier <code>notify</code> method. <code>notifier</code> object should inherit from BaseNotifier</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Callable</code> <p>function to decorate</p> <code>None</code>   <code>notifier</code> <code>BaseNotifier</code> <p>instance of a Notifier that implements <code>notify</code> method</p> <code>None</code>    <p>Usage:</p> <pre><code>from deczoo import notify_on_end\nfrom deczoo._base_notifier import BaseNotifier\n\nclass DummyNotifier(BaseNotifier):\n    def notify(self):\n        print(\"Function has finished\")\n\nnotifier = DummyNotifier()\n@notify_on_end(notifier=notifier)\ndef add(a, b): return a + b\n\n_ = add(1, 2)\n# Function has finished\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef notify_on_end(func: Callable = None, notifier: BaseNotifier = None) -&gt; Callable:\n    \"\"\"\n    Notify when func has finished running using the notifier `notify` method.\n    `notifier` object should inherit from BaseNotifier\n\n    Arguments:\n        func: function to decorate\n        notifier: instance of a Notifier that implements `notify` method\n\n    Usage:\n\n    ```python\n    from deczoo import notify_on_end\n    from deczoo._base_notifier import BaseNotifier\n\n    class DummyNotifier(BaseNotifier):\n        def notify(self):\n            print(\"Function has finished\")\n\n    notifier = DummyNotifier()\n    @notify_on_end(notifier=notifier)\n    def add(a, b): return a + b\n\n    _ = add(1, 2)\n    # Function has finished\n    ```\n    \"\"\"\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            raise e\n        finally:\n            notifier.notify()\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.retry","title":"<code>retry(func=None, n_tries=3, delay=0.0, logging_fn=&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;)</code>","text":"<p>Wraps a function with a retry block</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>n_tries</code> <code>int</code> <p>max number of attempts to try</p> <code>3</code>   <code>delay</code> <code>float</code> <p>time to wait before a retry</p> <code>0.0</code>   <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;</code>    <p>Usage:</p> <pre><code>from deczoo import retry\n\n@retry(n_tries=2, delay=1.)\ndef add(a, b): return a+b\n\n_ = add(1, 2)\n# Attempt 1/2: Successed\n\n_ = add(1, \"a\")\n# Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n# Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef retry(\n    func: Optional[Callable] = None,\n    n_tries: int = 3,\n    delay: float = 0.0,\n    logging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n    \"\"\"\n    Wraps a function with a retry block\n\n    Arguments:\n        func: function to decorate\n        n_tries: max number of attempts to try\n        delay: time to wait before a retry\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n\n    Usage:\n\n    ```python\n    from deczoo import retry\n\n    @retry(n_tries=2, delay=1.)\n    def add(a, b): return a+b\n\n    _ = add(1, 2)\n    # Attempt 1/2: Successed\n\n    _ = add(1, \"a\")\n    # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n    # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n    ```\n    \"\"\"\n    if not isinstance(n_tries, int) or n_tries &lt; 1:\n        raise ValueError(\"`n_tries` should be a positive integer\")\n\n    if not isinstance(delay, (int, float)) or delay &lt; 0:\n        raise ValueError(\"`delay` should be a positive number\")\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        attempt = 0\n\n        while attempt &lt; n_tries:\n\n            try:\n                res = func(*args, **kwargs)\n                logging_fn(f\"Attempt {attempt+1}/{n_tries}: Successed\")\n                return res\n\n            except Exception as e:\n                logging_fn(f\"Attempt {attempt+1}/{n_tries}: Failed with error: {e}\")\n\n                time.sleep(delay)\n                attempt += 1\n                if attempt == n_tries:\n                    raise e\n\n    return wrapper\n</code></pre>"},{"location":"api/decorators/#deczoo.decorators.timeout","title":"<code>timeout(func=None, time_limit=None, signal_handler=None, signum=&lt;Signals.SIGALRM: 14&gt;, logging_fn=&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;)</code>","text":"<p>Sets a time limit to a function, terminates the process if it hasn't finished within such time limit.</p> <p>Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX.</p> <p>Parameters:</p>    Name Type Description Default     <code>func</code> <code>Optional[Callable]</code> <p>function to decorate</p> <code>None</code>   <code>time_limit</code> <code>Optional[int]</code> <p>max time (in seconds) for function to run, 0 means no time limit</p> <code>None</code>   <code>signal_handler</code> <code>Optional[Callable]</code> <p>custom signal handler</p> <code>None</code>   <code>signum</code> <code>Union[int, enum.Enum]</code> <p>signal number to be used, default=signal.SIGALRM (14)</p> <code>&lt;Signals.SIGALRM: 14&gt;</code>   <code>logging_fn</code> <code>Callable</code> <p>log function (e.g. print, logger.info, rich console.print)</p> <code>&lt;bound method Console.log of &lt;console width=80 None&gt;&gt;</code>    <p>Usage:</p> <pre><code>import time\nfrom deczoo import timeout\n\n@timeout(time_limit=3)\ndef add(a, b):\n    time.sleep(2)\n    return a+b\n\nadd(1, 2)\n3\n\n@timeout(time_limit=1)\ndef add(a, b):\n    time.sleep(2)\n    return a+b\n\nadd(1, 2)\n# Exception: Reached time limit, terminating add\n</code></pre>  Source code in <code>deczoo/decorators.py</code> <pre><code>@check_parens\ndef timeout(\n    func: Optional[Callable] = None,\n    time_limit: Optional[int] = None,\n    signal_handler: Optional[Callable] = None,\n    signum: Union[int, Enum] = signal.SIGALRM,\n    logging_fn: Callable = LOGGING_FN,\n) -&gt; Callable:\n    \"\"\"\n    Sets a time limit to a function, terminates the process if it hasn't finished within\n    such time limit.\n\n    Remark that it uses the signal library (https://docs.python.org/3/library/signal.html)\n    which fully supported only on UNIX.\n\n    Arguments:\n        func: function to decorate\n        time_limit: max time (in seconds) for function to run, 0 means no time limit\n        signal_handler: custom signal handler\n        signum: signal number to be used, default=signal.SIGALRM (14)\n        logging_fn: log function (e.g. print, logger.info, rich console.print)\n\n    Usage:\n\n    ```python\n    import time\n    from deczoo import timeout\n\n    @timeout(time_limit=3)\n    def add(a, b):\n        time.sleep(2)\n        return a+b\n\n    add(1, 2)\n    3\n\n    @timeout(time_limit=1)\n    def add(a, b):\n        time.sleep(2)\n        return a+b\n\n    add(1, 2)\n    # Exception: Reached time limit, terminating add\n    ```\n    \"\"\"\n\n    if not isinstance(time_limit, (int, float)) or time_limit &lt; 0:\n        raise ValueError(\"`time_limit` should be a positive number\")\n\n    if signal_handler is None:\n\n        def signal_handler(signum, frame):\n            raise Exception(f\"Reached time limit, terminating {func.__name__}\")\n\n        signal.signal(signum, signal_handler)  # type: ignore\n\n    @wraps(func)  # type: ignore\n    def wrapper(*args, **kwargs):\n\n        signal.alarm(time_limit)\n\n        try:\n            res = func(*args, **kwargs)\n            signal.alarm(0)\n            return res\n        except Exception as e:\n            raise e\n\n    return wrapper\n</code></pre>"},{"location":"api/utils/","title":"Utility functions","text":""},{"location":"api/utils/#check_parens","title":"check_parens","text":"<p>Decorates a decorator function in order to check whether or not it gets called with parens, and therefore deal with its optional arguments.</p> <p>Parameters:</p>    Name Type Description Default     <code>decorator</code> <code>Callable</code> <p>decorator to wrap</p> required    <p>Usage:</p> <pre><code># `decorator` called default params, and without parens\n@decorator\ndef func(*func_args, **func_kwargs):\n    pass\n\n# `decorator` called with custom params, of course with parens\n@decorator(*args, **kwargs)\ndef func(*func_args, **func_kwargs):\n    pass\n</code></pre>  Source code in <code>deczoo/_utils.py</code> <pre><code>def check_parens(decorator: Callable) -&gt; Callable:\n    \"\"\"\n    Decorates a decorator function in order to check whether or not it gets called with\n    parens, and therefore deal with its optional arguments.\n\n    Arguments:\n        decorator: decorator to wrap\n\n    Usage:\n\n    ```python\n    # `decorator` called default params, and without parens\n    @decorator\n    def func(*func_args, **func_kwargs):\n        pass\n\n    # `decorator` called with custom params, of course with parens\n    @decorator(*args, **kwargs)\n    def func(*func_args, **func_kwargs):\n        pass\n    ```\n    \"\"\"\n\n    @wraps(decorator)\n    def wrapper(func: Callable = None, *args, **kwargs) -&gt; Callable:\n\n        if func is None:\n            return partial(decorator, *args, **kwargs)\n        else:\n            return decorator(func, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"quickstart/examples/","title":"Example Usage","text":""},{"location":"quickstart/examples/#call_counter","title":"call_counter","text":"<p>Counts how many times a function has been called, stores such values in the <code>_calls</code> attribute.</p> <pre><code>from deczoo import call_counter\n\n@call_counter\ndef add(a, b):\n    return a+b\n\nfor _ in range(3):\n    add(1,2)\n\nadd._calls\n3\n</code></pre>"},{"location":"quickstart/examples/#catch","title":"<code>catch</code>","text":"<p>Wraps a function in a try-except block, potentially prevent exception to be raised and return a custom value or raises custom exception.</p> <pre><code>from deczoo import catch\n\n@catch(return_on_exception=-999)\ndef add(a, b):\n    return a+b\n\nadd(1, 2)\n3\n\nadd(1, \"a\")\n-999\n</code></pre>"},{"location":"quickstart/examples/#check_args","title":"<code>check_args</code>","text":"<p>Checks that function arguments satisfy given rules.</p> <pre><code>from deczoo import check_args\n\n@check_args(a=lambda t: t&gt;0)\ndef add(a, b):\n    return a+b\n\nadd(1,2)\n3\n\nadd(-2, 2)\n# ValueError: Argument a doesn't satisfy its rule\n</code></pre>"},{"location":"quickstart/examples/#chime_on_end","title":"<code>chime_on_end</code>","text":"<p>Notify with chime sound whenever the function ends</p> <pre><code>from deczoo import chime_on_end\n\n@chime_on_end(theme=\"mario\")\ndef add(a, b):\n    return a+b\n\n_ = add(1, 2)\n# you should hear a sound now!\n</code></pre>"},{"location":"quickstart/examples/#log","title":"<code>log</code>","text":"<p>Tracks function time taken, arguments and errors</p> <pre><code>from deczoo import log\n\n@log\ndef add(a, b):\n    return a+b\n\n_ = add(1, 2)\n# add args=(a=1, b=2) time=0:00:00.000111\n</code></pre>"},{"location":"quickstart/examples/#timer","title":"<code>timer</code>","text":"<p>Tracks function time taken, to be honest this is nothing more than <pre><code>from functools import partial\n\ntimer = partial(log, log_time=True, log_args=False, log_error=False)\n</code></pre></p>"},{"location":"quickstart/examples/#memory_limit","title":"<code>memory_limit</code>","text":"<p>Sets a memory limit for a function</p> <pre><code>from deczoo import memory_limit\n\n@memory_limit(percentage=0.2)\ndef limited():\n    for i in list(range(10 ** 8)):\n        _ = 1 + 1\n    return \"done\"\n\ndef unlimited():\n    for i in list(range(10 ** 8)):\n        _ = 1 + 1\n    return \"done\"\n\nlimited()\n# MemoryError: Reached memory limit\n\nunlimited()\ndone\n</code></pre>"},{"location":"quickstart/examples/#retry","title":"<code>retry</code>","text":"<p>Wraps a function with a retry block</p> <pre><code>from deczoo import retry\n\n@retry(n_tries=2, delay=1.)\ndef add(a, b): return a+b\n\n_ = add(1, 2)\n# Attempt 1/2: Successed\n\n_ = add(1, \"a\")\n# Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n# Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'\n</code></pre>"},{"location":"quickstart/examples/#timeout","title":"<code>timeout</code>","text":"<p>Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX.</p> <pre><code>import time\nfrom deczoo import timeout\n\n@timeout(time_limit=3)\ndef add(a, b):\n    time.sleep(2)\n    return a+b\n\nadd(1, 2)\n3\n\n@timeout(time_limit=1)\ndef add(a, b):\n    time.sleep(2)\n    return a+b\n\nadd(1, 2)\n# Exception: Reached time limit, terminating add\n</code></pre>"}]}