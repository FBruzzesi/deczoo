{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"deczoo \u00b6 A zoo for decorators There are many great decorators out there that we use everyday. Why don't collect few of them? I found myself implementing over and over in different projects. The hope is to gather them here and use this codebase. Alpha Notice \u00b6 This package is really new and there are edge cases that probably doesn't cover (yet). Installation \u00b6 You can install the library using pip : python -m pip install deczoo Getting started \u00b6 We have a documentation page that explains how each feature works. Each function here is a decorator with a specific objective in mind. from deczoo import log @log # equivalent to @log(log_time=True, log_args=True, log_error=True, logging_fn=print) def my_add_function ( a , b , * args ): \"\"\"Adds all arguments together\"\"\" return sum ([ a , b , * args ]) _ = my_add_function ( 1 , 2 , 3 , 4 ) # my_add_function args=(a=1, b=2, args=(3, 4)) time=0:00:00.000062 _ = my_add_function ( 1 , \"a\" , 2 ) # my_add_function args=(a=1, b=a, args=(2,)) time=0:00:00.000064 Failed with error: unsupported # operand type(s) for +: 'int' and 'str' Features \u00b6 The library implements few (function) decorators: call_counter : Counts how many times a function has been called catch : Wraps a function in a try-except block check_args : Checks that function arguments satisfy given rules chime_on_end : Notify with chime sound on function end dump_result : Saves function result in a pickle file log : Tracks function time taken, arguments and errors timer : Tracks function time taken memory_limit : Sets a memory limit for a function retry : Wraps a function with a retry block timeout : Sets a time limit to a function to run Feedbacks \u00b6 Any feedback, improvement/enhancement or issue is welcome in the issue page of the repo. Contributing \u00b6 Make sure to check the issue list beforehand. To get started locally, you can clone the repo and quickly get started using the Makefile : git clone git@github.com:FBruzzesi/deczoo.git cd deczoo make init-develop Licence \u00b6 This repository has a MIT Licence","title":"Home"},{"location":"#deczoo","text":"A zoo for decorators There are many great decorators out there that we use everyday. Why don't collect few of them? I found myself implementing over and over in different projects. The hope is to gather them here and use this codebase.","title":"deczoo"},{"location":"#alpha-notice","text":"This package is really new and there are edge cases that probably doesn't cover (yet).","title":"Alpha Notice"},{"location":"#installation","text":"You can install the library using pip : python -m pip install deczoo","title":"Installation"},{"location":"#getting-started","text":"We have a documentation page that explains how each feature works. Each function here is a decorator with a specific objective in mind. from deczoo import log @log # equivalent to @log(log_time=True, log_args=True, log_error=True, logging_fn=print) def my_add_function ( a , b , * args ): \"\"\"Adds all arguments together\"\"\" return sum ([ a , b , * args ]) _ = my_add_function ( 1 , 2 , 3 , 4 ) # my_add_function args=(a=1, b=2, args=(3, 4)) time=0:00:00.000062 _ = my_add_function ( 1 , \"a\" , 2 ) # my_add_function args=(a=1, b=a, args=(2,)) time=0:00:00.000064 Failed with error: unsupported # operand type(s) for +: 'int' and 'str'","title":"Getting started"},{"location":"#features","text":"The library implements few (function) decorators: call_counter : Counts how many times a function has been called catch : Wraps a function in a try-except block check_args : Checks that function arguments satisfy given rules chime_on_end : Notify with chime sound on function end dump_result : Saves function result in a pickle file log : Tracks function time taken, arguments and errors timer : Tracks function time taken memory_limit : Sets a memory limit for a function retry : Wraps a function with a retry block timeout : Sets a time limit to a function to run","title":"Features"},{"location":"#feedbacks","text":"Any feedback, improvement/enhancement or issue is welcome in the issue page of the repo.","title":"Feedbacks"},{"location":"#contributing","text":"Make sure to check the issue list beforehand. To get started locally, you can clone the repo and quickly get started using the Makefile : git clone git@github.com:FBruzzesi/deczoo.git cd deczoo make init-develop","title":"Contributing"},{"location":"#licence","text":"This repository has a MIT Licence","title":"Licence"},{"location":"api/decorators/","text":"Available Decorators \u00b6 call_counter ( func = None , seed = 0 , log_counter = False , logging_fn = None ) \u00b6 Counts how many times a function has been called in the _calls attribute Parameters: Name Type Description Default func Callable function to decorate None seed int counter start, default=0 0 log_counter bool whether display count number, default=False False logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import call_counter @call_counter def add ( a , b ): return a + b for _ in range ( 3 ): add ( 1 , 2 ) add . _calls 3 Source code in deczoo/decorators.py @check_parens def call_counter ( func : Callable = None , seed : int = 0 , log_counter : bool = False , logging_fn : Callable = None , ) -> Callable : \"\"\" Counts how many times a function has been called in the `_calls` attribute Arguments: func: function to decorate seed: counter start, default=0 log_counter: whether display count number, default=False logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import call_counter @call_counter def add(a, b): return a+b for _ in range(3): add(1,2) add._calls 3 ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): wrapper . _calls += 1 if log_counter : logging_fn ( f \" { func . __name__ } called { wrapper . _calls } times\" ) return func ( * args , ** kwargs ) wrapper . _calls = seed return wrapper catch ( func = None , return_on_exception = None , raise_on_exception = None , logging_fn = None ) \u00b6 Wraps a function in a try-except block, potentially prevent exception to be raised or raises custom exception Parameters: Name Type Description Default func Callable function to decorate None return_on_exception Any value to return on exception None raise_on_exception Any error to raise on exception None logging_fn Callable log function (e.g. print, logger.info, rich console.print) None from deczoo import catch @catch ( return_on_exception =- 999 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( 1 , \"a\" ) - 999 Source code in deczoo/decorators.py @check_parens def catch ( func : Callable = None , return_on_exception : Any = None , raise_on_exception : Any = None , logging_fn : Callable = None , ) -> Callable : \"\"\" Wraps a function in a try-except block, potentially prevent exception to be raised or raises custom exception Arguments: func: function to decorate return_on_exception: value to return on exception raise_on_exception: error to raise on exception logging_fn: log function (e.g. print, logger.info, rich console.print) ```python from deczoo import catch @catch(return_on_exception=-999) def add(a, b): return a+b add(1, 2) 3 add(1, \"a\") -999 ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): try : return func ( * args , ** kwargs ) except Exception as e : if return_on_exception is not None : logging_fn ( f \"Failed with error { e } , returning { return_on_exception } \" ) return return_on_exception elif raise_on_exception is not None : logging_fn ( f \"Failed with error { e } \" ) raise raise_on_exception else : logging_fn ( f \"Failed with error { e } \" ) raise e return wrapper check_args ( func = None , ** rules ) \u00b6 Checks that function arguments satisfy given rules Parameters: Name Type Description Default func Callable function to decorate None rules Dict[str, Callable] rules to be satisfied {} Usage: from deczoo import check_args @check_args ( a = lambda t : t > 0 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( - 2 , 2 ) # ValueError: Argument a doesn't satisfy its rule Source code in deczoo/decorators.py @check_parens def check_args ( func : Callable = None , ** rules : Dict [ str , Callable ]) -> Callable : \"\"\" Checks that function arguments satisfy given rules Arguments: func: function to decorate rules: rules to be satisfied Usage: ```python from deczoo import check_args @check_args(a=lambda t: t>0) def add(a, b): return a+b add(1,2) 3 add(-2, 2) # ValueError: Argument a doesn't satisfy its rule ``` \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ) -> Callable : func_args = inspect . signature ( func ) . bind ( * args , ** kwargs ) . arguments for k , v in func_args . items (): rule = rules . get ( k ) if rule is not None : if not rule ( v ): raise ValueError ( f \"Argument { k } doesn't satisfy its rule\" ) res = func ( * args , ** kwargs ) return res return wrapper chime_on_end ( func = None , theme = None ) \u00b6 Notify with chime sound on function end Parameters: Name Type Description Default func Callable function to decorate None theme str chime theme to use None Usage: from deczoo import chime_on_end @chime_on_end def add ( a , b ): return a + b _ = add ( 1 , 2 ) # you should hear a sound now! Source code in deczoo/decorators.py @check_parens def chime_on_end ( func : Callable = None , theme : str = None ) -> Callable : \"\"\" Notify with chime sound on function end Arguments: func: function to decorate theme: chime theme to use Usage: ```python from deczoo import chime_on_end @chime_on_end def add(a, b): return a+b _ = add(1, 2) # you should hear a sound now! ``` \"\"\" chime . theme ( theme ) @wraps ( func ) def wrapper ( * args , ** kwargs ): try : res = func ( * args , ** kwargs ) chime . success () return res except Exception as e : chime . error () raise e return wrapper dump_result ( func = None , result_path = 'results' , include_args = False , include_time = True , time_fmt = '%Y%m %d _%H%M%S' , logging_fn = None ) \u00b6 Saves function result in a pickle file Parameters: Name Type Description Default func Callable function to decorate None result_path str path to folder where to save the result, default=\"results\" 'results' include_args bool whether to add arguments the function run with in the filename, default=False False include_time bool whether to add when the function run in the filename, default=True True time_fmt str time format, used only if include_time=True, default=\"%Y%m%d_%H%M%S\" '%Y%m%d_%H%M%S' logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import dump_result @dump_result def add ( a , b ): return a + b _ = add ( 1 , 2 ) # will save the result in results/add_%Y%m%d_%H%M%S.pickle Source code in deczoo/decorators.py @check_parens def dump_result ( func : Callable = None , result_path : str = \"results\" , include_args : bool = False , include_time : bool = True , time_fmt : str = \"%Y%m %d _%H%M%S\" , logging_fn : Callable = None , ) -> Callable : \"\"\" Saves function result in a pickle file Arguments: func: function to decorate result_path: path to folder where to save the result, default=\"results\" include_args: whether to add arguments the function run with in the filename, default=False include_time: whether to add when the function run in the filename, default=True time_fmt: time format, used only if include_time=True, default=\"%Y%m%d_%H%M%S\" logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import dump_result @dump_result def add(a, b): return a+b _ = add(1, 2) # will save the result in results/add_%Y%m%d_%H%M%S.pickle ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN if not os . path . exists ( result_path ): os . makedirs ( result_path ) @wraps ( func ) def wrapper ( * args , ** kwargs ): res = func ( * args , ** kwargs ) func_args_str = \"\" func_time_str = \"\" if include_args : func_args = inspect . signature ( func ) . bind ( * args , ** kwargs ) . arguments func_args_str = \"_\" + \"_\" . join ( f \" { v } \" for v in func_args . values ()) if include_time : func_time_str = f \"_ { datetime . now () . strftime ( time_fmt ) } \" _file = f \" { result_path } / { func . __name__ }{ func_args_str }{ func_time_str } .pickle\" with open ( _file , \"wb\" ) as outp : pickle . dump ( res , outp , pickle . HIGHEST_PROTOCOL ) logging_fn ( f \"Result of { func . __name__ } saved at { _file } \" ) return res return wrapper log ( func = None , log_time = True , log_args = True , log_error = True , log_file = None , logging_fn = None ) \u00b6 Tracks function time taken, arguments and errors Parameters: Name Type Description Default func Callable function to decorate None log_time bool whether to log time taken or not, default=True True log_args bool whether to log arguments or not, default=True True log_error bool whether to log error or not, default=True True log_file str filepath where to write log, default=None None logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import log @log def add ( a , b ): return a + b _ = add ( 1 , 2 ) # add args=(a=1, b=2) time=0:00:00.000111 Source code in deczoo/decorators.py @check_parens def log ( func : Callable = None , log_time : bool = True , log_args : bool = True , log_error : bool = True , log_file : str = None , logging_fn : Callable = None , ) -> Callable : \"\"\" Tracks function time taken, arguments and errors Arguments: func: function to decorate log_time: whether to log time taken or not, default=True log_args: whether to log arguments or not, default=True log_error: whether to log error or not, default=True log_file: filepath where to write log, default=None logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import log @log def add(a, b): return a+b _ = add(1, 2) # add args=(a=1, b=2) time=0:00:00.000111 ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): tic = datetime . now () if log_args : func_args = inspect . signature ( func ) . bind ( * args , ** kwargs ) . arguments func_args_str = \", \" . join ( f \" { k } = { v } \" for k , v in func_args . items ()) optional_strings = [ f \"args=( { func_args_str } )\" ] else : optional_strings = [] try : res = func ( * args , ** kwargs ) toc = datetime . now () optional_strings += [ f \"time= { toc - tic } \" if log_time else None , ] return res except Exception as e : toc = datetime . now () optional_strings += [ f \"time= { toc - tic } \" if log_time else None , \"Failed\" + ( f \" with error: { e } \" if log_error else \"\" ), ] raise e finally : log_string = ( f \" { func . __name__ } { ' ' . join ([ s for s in optional_strings if s ]) } \" ) logging_fn ( log_string ) if log_file is not None : with open ( log_file , \"a\" ) as f : f . write ( f \" { tic } { log_string } \\n \" ) return wrapper memory_limit ( func = None , percentage = 0.99 , logging_fn =< built - in function print > ) \u00b6 Sets a memory limit for a function Parameters: Name Type Description Default func Callable function to decorate None percentage float percentage of the currently available memory to use, default=0.99 0.99 logging_fn Callable log function (e.g. print, logger.info, rich console.print) <built-in function print> Usage: from deczoo import memory_limit # Running on WSL2 with 12 Gb RAM @memory_limit ( percentage = 0.2 ) def limited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" def unlimited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" limited () # MemoryError: Reached memory limit unlimited () done Source code in deczoo/decorators.py @check_parens def memory_limit ( func : Callable = None , percentage : float = 0.99 , logging_fn : Callable = print ) -> Callable : \"\"\" Sets a memory limit for a function Arguments: func: function to decorate percentage: percentage of the currently available memory to use, default=0.99 logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import memory_limit # Running on WSL2 with 12 Gb RAM @memory_limit(percentage=0.2) def limited(): for i in list(range(10 ** 8)): _ = 1 + 1 return \"done\" def unlimited(): for i in list(range(10 ** 8)): _ = 1 + 1 return \"done\" limited() # MemoryError: Reached memory limit unlimited() done ``` \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): _ , hard = resource . getrlimit ( resource . RLIMIT_AS ) free_memory = _get_free_memory () * 1024 logging_fn ( f \"Setting memory limit for { func . __name__ } to { int ( free_memory * percentage ) } \" ) resource . setrlimit ( resource . RLIMIT_AS , ( int ( free_memory * percentage ), hard )) try : return func ( * args , ** kwargs ) except MemoryError : raise MemoryError ( \"Reached memory limit\" ) finally : resource . setrlimit ( resource . RLIMIT_AS , ( int ( free_memory ), hard )) return wrapper retry ( func = None , n_tries = 1 , delay = 0.0 , logging_fn = None ) \u00b6 Wraps a function with a retry block Parameters: Name Type Description Default func Callable function to decorate None n_tries int max number of attempts to try, default=1 1 delay float time to wait before a retry, default=0 0.0 logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import retry @retry ( n_tries = 2 , delay = 1. ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # Attempt 1/2: Successed _ = add ( 1 , \"a\" ) # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' Source code in deczoo/decorators.py @check_parens def retry ( func : Callable = None , n_tries : int = 1 , delay : float = 0.0 , logging_fn : Callable = None , ) -> Callable : \"\"\" Wraps a function with a retry block Arguments: func: function to decorate n_tries: max number of attempts to try, default=1 delay: time to wait before a retry, default=0 logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import retry @retry(n_tries=2, delay=1.) def add(a, b): return a+b _ = add(1, 2) # Attempt 1/2: Successed _ = add(1, \"a\") # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): attempt = 0 while attempt < n_tries : try : res = func ( * args , ** kwargs ) logging_fn ( f \"Attempt { attempt + 1 } / { n_tries } : Successed\" ) return res except Exception as e : logging_fn ( f \"Attempt { attempt + 1 } / { n_tries } : Failed with error: { e } \" ) time . sleep ( delay ) attempt += 1 if attempt == n_tries : raise e return wrapper timeout ( func = None , time_limit = 0 , signal_handler = None , signum =< Signals . SIGALRM : 14 > , logging_fn = None ) \u00b6 Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX. Parameters: Name Type Description Default func Callable function to decorate None time_limit int max time (in seconds) for function to run, 0 means no time limit, default=0 0 signal_handler Callable custom signal handler None signum Union[int, enum.Enum] signal number to be used, default=signal.SIGALRM (14) <Signals.SIGALRM: 14> logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: import time from deczoo import timeout @timeout ( time_limit = 3 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) 3 @timeout ( time_limit = 1 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) # Exception: Reached time limit, terminating add Source code in deczoo/decorators.py @check_parens def timeout ( func : Callable = None , time_limit : int = 0 , signal_handler : Callable = None , signum : Union [ int , Enum ] = signal . SIGALRM , logging_fn : Callable = None , ) -> Callable : \"\"\" Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX. Arguments: func: function to decorate time_limit: max time (in seconds) for function to run, 0 means no time limit, default=0 signal_handler: custom signal handler signum: signal number to be used, default=signal.SIGALRM (14) logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python import time from deczoo import timeout @timeout(time_limit=3) def add(a, b): time.sleep(2) return a+b add(1, 2) 3 @timeout(time_limit=1) def add(a, b): time.sleep(2) return a+b add(1, 2) # Exception: Reached time limit, terminating add ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN if signal_handler is None : def signal_handler ( signum , frame ): raise Exception ( f \"Reached time limit, terminating { func . __name__ } \" ) signal . signal ( signum , signal_handler ) @wraps ( func ) def wrapper ( * args , ** kwargs ): signal . alarm ( time_limit ) try : res = func ( * args , ** kwargs ) signal . alarm ( 0 ) return res except Exception as e : raise e return wrapper","title":"Decorators"},{"location":"api/decorators/#available-decorators","text":"","title":"Available Decorators"},{"location":"api/decorators/#deczoo.decorators.call_counter","text":"Counts how many times a function has been called in the _calls attribute Parameters: Name Type Description Default func Callable function to decorate None seed int counter start, default=0 0 log_counter bool whether display count number, default=False False logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import call_counter @call_counter def add ( a , b ): return a + b for _ in range ( 3 ): add ( 1 , 2 ) add . _calls 3 Source code in deczoo/decorators.py @check_parens def call_counter ( func : Callable = None , seed : int = 0 , log_counter : bool = False , logging_fn : Callable = None , ) -> Callable : \"\"\" Counts how many times a function has been called in the `_calls` attribute Arguments: func: function to decorate seed: counter start, default=0 log_counter: whether display count number, default=False logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import call_counter @call_counter def add(a, b): return a+b for _ in range(3): add(1,2) add._calls 3 ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): wrapper . _calls += 1 if log_counter : logging_fn ( f \" { func . __name__ } called { wrapper . _calls } times\" ) return func ( * args , ** kwargs ) wrapper . _calls = seed return wrapper","title":"call_counter()"},{"location":"api/decorators/#deczoo.decorators.catch","text":"Wraps a function in a try-except block, potentially prevent exception to be raised or raises custom exception Parameters: Name Type Description Default func Callable function to decorate None return_on_exception Any value to return on exception None raise_on_exception Any error to raise on exception None logging_fn Callable log function (e.g. print, logger.info, rich console.print) None from deczoo import catch @catch ( return_on_exception =- 999 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( 1 , \"a\" ) - 999 Source code in deczoo/decorators.py @check_parens def catch ( func : Callable = None , return_on_exception : Any = None , raise_on_exception : Any = None , logging_fn : Callable = None , ) -> Callable : \"\"\" Wraps a function in a try-except block, potentially prevent exception to be raised or raises custom exception Arguments: func: function to decorate return_on_exception: value to return on exception raise_on_exception: error to raise on exception logging_fn: log function (e.g. print, logger.info, rich console.print) ```python from deczoo import catch @catch(return_on_exception=-999) def add(a, b): return a+b add(1, 2) 3 add(1, \"a\") -999 ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): try : return func ( * args , ** kwargs ) except Exception as e : if return_on_exception is not None : logging_fn ( f \"Failed with error { e } , returning { return_on_exception } \" ) return return_on_exception elif raise_on_exception is not None : logging_fn ( f \"Failed with error { e } \" ) raise raise_on_exception else : logging_fn ( f \"Failed with error { e } \" ) raise e return wrapper","title":"catch()"},{"location":"api/decorators/#deczoo.decorators.check_args","text":"Checks that function arguments satisfy given rules Parameters: Name Type Description Default func Callable function to decorate None rules Dict[str, Callable] rules to be satisfied {} Usage: from deczoo import check_args @check_args ( a = lambda t : t > 0 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( - 2 , 2 ) # ValueError: Argument a doesn't satisfy its rule Source code in deczoo/decorators.py @check_parens def check_args ( func : Callable = None , ** rules : Dict [ str , Callable ]) -> Callable : \"\"\" Checks that function arguments satisfy given rules Arguments: func: function to decorate rules: rules to be satisfied Usage: ```python from deczoo import check_args @check_args(a=lambda t: t>0) def add(a, b): return a+b add(1,2) 3 add(-2, 2) # ValueError: Argument a doesn't satisfy its rule ``` \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ) -> Callable : func_args = inspect . signature ( func ) . bind ( * args , ** kwargs ) . arguments for k , v in func_args . items (): rule = rules . get ( k ) if rule is not None : if not rule ( v ): raise ValueError ( f \"Argument { k } doesn't satisfy its rule\" ) res = func ( * args , ** kwargs ) return res return wrapper","title":"check_args()"},{"location":"api/decorators/#deczoo.decorators.chime_on_end","text":"Notify with chime sound on function end Parameters: Name Type Description Default func Callable function to decorate None theme str chime theme to use None Usage: from deczoo import chime_on_end @chime_on_end def add ( a , b ): return a + b _ = add ( 1 , 2 ) # you should hear a sound now! Source code in deczoo/decorators.py @check_parens def chime_on_end ( func : Callable = None , theme : str = None ) -> Callable : \"\"\" Notify with chime sound on function end Arguments: func: function to decorate theme: chime theme to use Usage: ```python from deczoo import chime_on_end @chime_on_end def add(a, b): return a+b _ = add(1, 2) # you should hear a sound now! ``` \"\"\" chime . theme ( theme ) @wraps ( func ) def wrapper ( * args , ** kwargs ): try : res = func ( * args , ** kwargs ) chime . success () return res except Exception as e : chime . error () raise e return wrapper","title":"chime_on_end()"},{"location":"api/decorators/#deczoo.decorators.dump_result","text":"Saves function result in a pickle file Parameters: Name Type Description Default func Callable function to decorate None result_path str path to folder where to save the result, default=\"results\" 'results' include_args bool whether to add arguments the function run with in the filename, default=False False include_time bool whether to add when the function run in the filename, default=True True time_fmt str time format, used only if include_time=True, default=\"%Y%m%d_%H%M%S\" '%Y%m%d_%H%M%S' logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import dump_result @dump_result def add ( a , b ): return a + b _ = add ( 1 , 2 ) # will save the result in results/add_%Y%m%d_%H%M%S.pickle Source code in deczoo/decorators.py @check_parens def dump_result ( func : Callable = None , result_path : str = \"results\" , include_args : bool = False , include_time : bool = True , time_fmt : str = \"%Y%m %d _%H%M%S\" , logging_fn : Callable = None , ) -> Callable : \"\"\" Saves function result in a pickle file Arguments: func: function to decorate result_path: path to folder where to save the result, default=\"results\" include_args: whether to add arguments the function run with in the filename, default=False include_time: whether to add when the function run in the filename, default=True time_fmt: time format, used only if include_time=True, default=\"%Y%m%d_%H%M%S\" logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import dump_result @dump_result def add(a, b): return a+b _ = add(1, 2) # will save the result in results/add_%Y%m%d_%H%M%S.pickle ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN if not os . path . exists ( result_path ): os . makedirs ( result_path ) @wraps ( func ) def wrapper ( * args , ** kwargs ): res = func ( * args , ** kwargs ) func_args_str = \"\" func_time_str = \"\" if include_args : func_args = inspect . signature ( func ) . bind ( * args , ** kwargs ) . arguments func_args_str = \"_\" + \"_\" . join ( f \" { v } \" for v in func_args . values ()) if include_time : func_time_str = f \"_ { datetime . now () . strftime ( time_fmt ) } \" _file = f \" { result_path } / { func . __name__ }{ func_args_str }{ func_time_str } .pickle\" with open ( _file , \"wb\" ) as outp : pickle . dump ( res , outp , pickle . HIGHEST_PROTOCOL ) logging_fn ( f \"Result of { func . __name__ } saved at { _file } \" ) return res return wrapper","title":"dump_result()"},{"location":"api/decorators/#deczoo.decorators.log","text":"Tracks function time taken, arguments and errors Parameters: Name Type Description Default func Callable function to decorate None log_time bool whether to log time taken or not, default=True True log_args bool whether to log arguments or not, default=True True log_error bool whether to log error or not, default=True True log_file str filepath where to write log, default=None None logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import log @log def add ( a , b ): return a + b _ = add ( 1 , 2 ) # add args=(a=1, b=2) time=0:00:00.000111 Source code in deczoo/decorators.py @check_parens def log ( func : Callable = None , log_time : bool = True , log_args : bool = True , log_error : bool = True , log_file : str = None , logging_fn : Callable = None , ) -> Callable : \"\"\" Tracks function time taken, arguments and errors Arguments: func: function to decorate log_time: whether to log time taken or not, default=True log_args: whether to log arguments or not, default=True log_error: whether to log error or not, default=True log_file: filepath where to write log, default=None logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import log @log def add(a, b): return a+b _ = add(1, 2) # add args=(a=1, b=2) time=0:00:00.000111 ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): tic = datetime . now () if log_args : func_args = inspect . signature ( func ) . bind ( * args , ** kwargs ) . arguments func_args_str = \", \" . join ( f \" { k } = { v } \" for k , v in func_args . items ()) optional_strings = [ f \"args=( { func_args_str } )\" ] else : optional_strings = [] try : res = func ( * args , ** kwargs ) toc = datetime . now () optional_strings += [ f \"time= { toc - tic } \" if log_time else None , ] return res except Exception as e : toc = datetime . now () optional_strings += [ f \"time= { toc - tic } \" if log_time else None , \"Failed\" + ( f \" with error: { e } \" if log_error else \"\" ), ] raise e finally : log_string = ( f \" { func . __name__ } { ' ' . join ([ s for s in optional_strings if s ]) } \" ) logging_fn ( log_string ) if log_file is not None : with open ( log_file , \"a\" ) as f : f . write ( f \" { tic } { log_string } \\n \" ) return wrapper","title":"log()"},{"location":"api/decorators/#deczoo.decorators.memory_limit","text":"Sets a memory limit for a function Parameters: Name Type Description Default func Callable function to decorate None percentage float percentage of the currently available memory to use, default=0.99 0.99 logging_fn Callable log function (e.g. print, logger.info, rich console.print) <built-in function print> Usage: from deczoo import memory_limit # Running on WSL2 with 12 Gb RAM @memory_limit ( percentage = 0.2 ) def limited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" def unlimited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" limited () # MemoryError: Reached memory limit unlimited () done Source code in deczoo/decorators.py @check_parens def memory_limit ( func : Callable = None , percentage : float = 0.99 , logging_fn : Callable = print ) -> Callable : \"\"\" Sets a memory limit for a function Arguments: func: function to decorate percentage: percentage of the currently available memory to use, default=0.99 logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import memory_limit # Running on WSL2 with 12 Gb RAM @memory_limit(percentage=0.2) def limited(): for i in list(range(10 ** 8)): _ = 1 + 1 return \"done\" def unlimited(): for i in list(range(10 ** 8)): _ = 1 + 1 return \"done\" limited() # MemoryError: Reached memory limit unlimited() done ``` \"\"\" @wraps ( func ) def wrapper ( * args , ** kwargs ): _ , hard = resource . getrlimit ( resource . RLIMIT_AS ) free_memory = _get_free_memory () * 1024 logging_fn ( f \"Setting memory limit for { func . __name__ } to { int ( free_memory * percentage ) } \" ) resource . setrlimit ( resource . RLIMIT_AS , ( int ( free_memory * percentage ), hard )) try : return func ( * args , ** kwargs ) except MemoryError : raise MemoryError ( \"Reached memory limit\" ) finally : resource . setrlimit ( resource . RLIMIT_AS , ( int ( free_memory ), hard )) return wrapper","title":"memory_limit()"},{"location":"api/decorators/#deczoo.decorators.retry","text":"Wraps a function with a retry block Parameters: Name Type Description Default func Callable function to decorate None n_tries int max number of attempts to try, default=1 1 delay float time to wait before a retry, default=0 0.0 logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: from deczoo import retry @retry ( n_tries = 2 , delay = 1. ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # Attempt 1/2: Successed _ = add ( 1 , \"a\" ) # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' Source code in deczoo/decorators.py @check_parens def retry ( func : Callable = None , n_tries : int = 1 , delay : float = 0.0 , logging_fn : Callable = None , ) -> Callable : \"\"\" Wraps a function with a retry block Arguments: func: function to decorate n_tries: max number of attempts to try, default=1 delay: time to wait before a retry, default=0 logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python from deczoo import retry @retry(n_tries=2, delay=1.) def add(a, b): return a+b _ = add(1, 2) # Attempt 1/2: Successed _ = add(1, \"a\") # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN @wraps ( func ) def wrapper ( * args , ** kwargs ): attempt = 0 while attempt < n_tries : try : res = func ( * args , ** kwargs ) logging_fn ( f \"Attempt { attempt + 1 } / { n_tries } : Successed\" ) return res except Exception as e : logging_fn ( f \"Attempt { attempt + 1 } / { n_tries } : Failed with error: { e } \" ) time . sleep ( delay ) attempt += 1 if attempt == n_tries : raise e return wrapper","title":"retry()"},{"location":"api/decorators/#deczoo.decorators.timeout","text":"Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX. Parameters: Name Type Description Default func Callable function to decorate None time_limit int max time (in seconds) for function to run, 0 means no time limit, default=0 0 signal_handler Callable custom signal handler None signum Union[int, enum.Enum] signal number to be used, default=signal.SIGALRM (14) <Signals.SIGALRM: 14> logging_fn Callable log function (e.g. print, logger.info, rich console.print) None Usage: import time from deczoo import timeout @timeout ( time_limit = 3 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) 3 @timeout ( time_limit = 1 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) # Exception: Reached time limit, terminating add Source code in deczoo/decorators.py @check_parens def timeout ( func : Callable = None , time_limit : int = 0 , signal_handler : Callable = None , signum : Union [ int , Enum ] = signal . SIGALRM , logging_fn : Callable = None , ) -> Callable : \"\"\" Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX. Arguments: func: function to decorate time_limit: max time (in seconds) for function to run, 0 means no time limit, default=0 signal_handler: custom signal handler signum: signal number to be used, default=signal.SIGALRM (14) logging_fn: log function (e.g. print, logger.info, rich console.print) Usage: ```python import time from deczoo import timeout @timeout(time_limit=3) def add(a, b): time.sleep(2) return a+b add(1, 2) 3 @timeout(time_limit=1) def add(a, b): time.sleep(2) return a+b add(1, 2) # Exception: Reached time limit, terminating add ``` \"\"\" if logging_fn is None : logging_fn = LOGGING_FN if signal_handler is None : def signal_handler ( signum , frame ): raise Exception ( f \"Reached time limit, terminating { func . __name__ } \" ) signal . signal ( signum , signal_handler ) @wraps ( func ) def wrapper ( * args , ** kwargs ): signal . alarm ( time_limit ) try : res = func ( * args , ** kwargs ) signal . alarm ( 0 ) return res except Exception as e : raise e return wrapper","title":"timeout()"},{"location":"api/utils/","text":"Utility functions \u00b6 check_parens ( decorator ) \u00b6 Decorates a decorator function in order to check if it gets called with or without parens, and therefore deal with its optional arguments. In such a way decorator can be called both with or without params: # `decorator` called default params, and without parens @decorator def func ( * func_args , ** func_kwargs ): pass # `decorator` called with custom params, of course with parens @decorator ( * args , ** kwargs ) def func ( * func_args , ** func_kwargs ): pass Source code in deczoo/_utils.py def check_parens ( decorator : Callable ) -> Callable : \"\"\" Decorates a decorator function in order to check if it gets called with or without parens, and therefore deal with its optional arguments. In such a way decorator can be called both with or without params: ```python # `decorator` called default params, and without parens @decorator def func(*func_args, **func_kwargs): pass # `decorator` called with custom params, of course with parens @decorator(*args, **kwargs) def func(*func_args, **func_kwargs): pass ``` \"\"\" @wraps ( decorator ) def wrapper ( func : Callable = None , * args , ** kwargs ) -> Callable : if func is None : return partial ( decorator , * args , ** kwargs ) else : return decorator ( func , * args , ** kwargs ) return wrapper","title":"Utils"},{"location":"api/utils/#utility-functions","text":"","title":"Utility functions"},{"location":"api/utils/#deczoo._utils.check_parens","text":"Decorates a decorator function in order to check if it gets called with or without parens, and therefore deal with its optional arguments. In such a way decorator can be called both with or without params: # `decorator` called default params, and without parens @decorator def func ( * func_args , ** func_kwargs ): pass # `decorator` called with custom params, of course with parens @decorator ( * args , ** kwargs ) def func ( * func_args , ** func_kwargs ): pass Source code in deczoo/_utils.py def check_parens ( decorator : Callable ) -> Callable : \"\"\" Decorates a decorator function in order to check if it gets called with or without parens, and therefore deal with its optional arguments. In such a way decorator can be called both with or without params: ```python # `decorator` called default params, and without parens @decorator def func(*func_args, **func_kwargs): pass # `decorator` called with custom params, of course with parens @decorator(*args, **kwargs) def func(*func_args, **func_kwargs): pass ``` \"\"\" @wraps ( decorator ) def wrapper ( func : Callable = None , * args , ** kwargs ) -> Callable : if func is None : return partial ( decorator , * args , ** kwargs ) else : return decorator ( func , * args , ** kwargs ) return wrapper","title":"check_parens()"},{"location":"quickstart/examples/","text":"Example Usage \u00b6 call_counter \u00b6 Counts how many times a function has been called, stores such values in the _calls attribute. from deczoo import call_counter @call_counter def add ( a , b ): return a + b for _ in range ( 3 ): add ( 1 , 2 ) add . _calls 3 catch \u00b6 Wraps a function in a try-except block, potentially prevent exception to be raised and return a custom value or raises custom exception. from deczoo import catch @catch ( return_on_exception =- 999 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( 1 , \"a\" ) - 999 check_args \u00b6 Checks that function arguments satisfy given rules. from deczoo import check_args @check_args ( a = lambda t : t > 0 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( - 2 , 2 ) # ValueError: Argument a doesn't satisfy its rule chime_on_end \u00b6 Notify with chime sound whenever the function ends from deczoo import chime_on_end @chime_on_end ( theme = \"mario\" ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # you should hear a sound now! dump_result \u00b6 Saves function result in a pickle file, eventually creates a results folder if doesn't exist. from deczoo import dump_result @dump_result ( include_args = True ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # will save the result in results/add_1_2_%Y%m%d_%H%M%S.pickle log \u00b6 Tracks function time taken, arguments and errors from deczoo import log @log def add ( a , b ): return a + b _ = add ( 1 , 2 ) # add args=(a=1, b=2) time=0:00:00.000111 timer \u00b6 Tracks function time taken, to be honest this is nothing more than from functools import partial timer = partial ( log , log_time = True , log_args = False , log_error = False ) memory_limit \u00b6 Sets a memory limit for a function from deczoo import memory_limit @memory_limit ( percentage = 0.2 ) def limited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" def unlimited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" limited () # MemoryError: Reached memory limit unlimited () done retry \u00b6 Wraps a function with a retry block from deczoo import retry @retry ( n_tries = 2 , delay = 1. ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # Attempt 1/2: Successed _ = add ( 1 , \"a\" ) # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' timeout \u00b6 Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX. import time from deczoo import timeout @timeout ( time_limit = 3 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) 3 @timeout ( time_limit = 1 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) # Exception: Reached time limit, terminating add","title":"Example Usage"},{"location":"quickstart/examples/#example-usage","text":"","title":"Example Usage"},{"location":"quickstart/examples/#call_counter","text":"Counts how many times a function has been called, stores such values in the _calls attribute. from deczoo import call_counter @call_counter def add ( a , b ): return a + b for _ in range ( 3 ): add ( 1 , 2 ) add . _calls 3","title":"call_counter"},{"location":"quickstart/examples/#catch","text":"Wraps a function in a try-except block, potentially prevent exception to be raised and return a custom value or raises custom exception. from deczoo import catch @catch ( return_on_exception =- 999 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( 1 , \"a\" ) - 999","title":"catch"},{"location":"quickstart/examples/#check_args","text":"Checks that function arguments satisfy given rules. from deczoo import check_args @check_args ( a = lambda t : t > 0 ) def add ( a , b ): return a + b add ( 1 , 2 ) 3 add ( - 2 , 2 ) # ValueError: Argument a doesn't satisfy its rule","title":"check_args"},{"location":"quickstart/examples/#chime_on_end","text":"Notify with chime sound whenever the function ends from deczoo import chime_on_end @chime_on_end ( theme = \"mario\" ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # you should hear a sound now!","title":"chime_on_end"},{"location":"quickstart/examples/#dump_result","text":"Saves function result in a pickle file, eventually creates a results folder if doesn't exist. from deczoo import dump_result @dump_result ( include_args = True ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # will save the result in results/add_1_2_%Y%m%d_%H%M%S.pickle","title":"dump_result"},{"location":"quickstart/examples/#log","text":"Tracks function time taken, arguments and errors from deczoo import log @log def add ( a , b ): return a + b _ = add ( 1 , 2 ) # add args=(a=1, b=2) time=0:00:00.000111","title":"log"},{"location":"quickstart/examples/#timer","text":"Tracks function time taken, to be honest this is nothing more than from functools import partial timer = partial ( log , log_time = True , log_args = False , log_error = False )","title":"timer"},{"location":"quickstart/examples/#memory_limit","text":"Sets a memory limit for a function from deczoo import memory_limit @memory_limit ( percentage = 0.2 ) def limited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" def unlimited (): for i in list ( range ( 10 ** 8 )): _ = 1 + 1 return \"done\" limited () # MemoryError: Reached memory limit unlimited () done","title":"memory_limit"},{"location":"quickstart/examples/#retry","text":"Wraps a function with a retry block from deczoo import retry @retry ( n_tries = 2 , delay = 1. ) def add ( a , b ): return a + b _ = add ( 1 , 2 ) # Attempt 1/2: Successed _ = add ( 1 , \"a\" ) # Attempt 1/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str' # Attempt 2/2: Failed with error: unsupported operand type(s) for +: 'int' and 'str'","title":"retry"},{"location":"quickstart/examples/#timeout","text":"Sets a time limit to a function, terminates the process if it hasn't finished within such time limit. Remark that it uses the signal library (https://docs.python.org/3/library/signal.html) which fully supported only on UNIX. import time from deczoo import timeout @timeout ( time_limit = 3 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) 3 @timeout ( time_limit = 1 ) def add ( a , b ): time . sleep ( 2 ) return a + b add ( 1 , 2 ) # Exception: Reached time limit, terminating add","title":"timeout"}]}